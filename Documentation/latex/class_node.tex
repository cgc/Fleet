\hypertarget{class_node}{}\section{Node Class Reference}
\label{class_node}\index{Node@{Node}}


{\ttfamily \#include $<$Node.\+h$>$}



Inheritance diagram for Node\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=184pt]{class_node__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Node\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=286pt]{class_node__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_node_ae33050869651f64551da2d13ad2a9dbc}{Node} (const \hyperlink{class_rule}{Rule} $\ast$r=nullptr, double \+\_\+lp=0.\+0, bool cr=true)
\item 
\hyperlink{class_node_a277918b68827f6ffd8150f450b0c12c3}{Node} (const \hyperlink{class_node}{Node} \&n)
\item 
\hyperlink{class_node_a87c9938dcd77c169802a732c98204945}{Node} (\hyperlink{class_node}{Node} \&\&n)
\item 
virtual \hyperlink{class_node_af5e3fa79300bf5f3f2f3ecae6e795a94}{$\sim$\+Node} ()
\item 
\hyperlink{_nonterminal_8h_a1c5bfe9b903f69c83bbde5da7035fef3}{nonterminal\+\_\+t} \hyperlink{class_node_aa727c354e38f60fb1560d72ae1aaa9af}{type} (const size\+\_\+t i) const
\item 
void \hyperlink{class_node_afff50c3712b8e30fffd479cad4eee023}{set\+\_\+child} (size\+\_\+t i, \hyperlink{class_node}{Node} \&n)
\item 
void \hyperlink{class_node_a486882370d2c9592c6eabb52a3289253}{set\+\_\+child} (size\+\_\+t i, \hyperlink{class_node}{Node} \&\&n)
\item 
void \hyperlink{class_node_addbfe90949f473c91203389f48095cf0}{operator=} (const \hyperlink{class_node}{Node} \&n)
\item 
void \hyperlink{class_node_abcd5c8ca2ea54716a72f7e27f9a9c937}{operator=} (\hyperlink{class_node}{Node} \&\&n)
\item 
bool \hyperlink{class_node_a8b05feb361beb04d465619751a2297b1}{operator$<$} (const \hyperlink{class_node}{Node} \&n) const
\item 
\hyperlink{_nonterminal_8h_a1c5bfe9b903f69c83bbde5da7035fef3}{nonterminal\+\_\+t} \hyperlink{class_node_a4abe3acdc804489a01ef13a25b130fd8}{nt} () const
\item 
bool \hyperlink{class_node_a895ef3b66f975fbaec1e5866a57afbed}{is\+\_\+null} () const
\item 
virtual size\+\_\+t \hyperlink{class_node_a9dde16ce87ed78ca8c49f8b4c3be42f3}{count\+\_\+nonnull} () const
\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{class_node_ac91282056a0df2835f1579bdd21c93e1}{sum} (std\+::function$<$ T(const \hyperlink{class_node}{Node} \&)$>$ \&f) const
\item 
{\footnotesize template$<$typename T $>$ }\\T \hyperlink{class_node_a089e99addd93f91b2ef5a9d0c3e6bdeb}{sum} (T($\ast$f)(const \hyperlink{class_node}{Node} \&)) const
\item 
bool \hyperlink{class_node_ac6f1a0f5274eae688c1959aecbfde2b0}{all} (std\+::function$<$ bool(const \hyperlink{class_node}{Node} \&)$>$ \&f) const
\item 
void \hyperlink{class_node_adefac3cb7b411321c5af15dad1484834}{map} (const std\+::function$<$ void(\hyperlink{class_node}{Node} \&)$>$ \&f)
\item 
virtual bool \hyperlink{class_node_ac2e36754ba8b1b1d452deeb2bdbd346f}{is\+\_\+complete} () const
\item 
virtual std\+::string \hyperlink{class_node_a5d2a0e17dd2a00a79e6d1f763c9114d0}{string} (bool usedot=true) const override
\item 
virtual std\+::string \hyperlink{class_node_a70e879ceb71f47787137572d9bee8efa}{parseable} () const
\item 
virtual size\+\_\+t \hyperlink{class_node_a377548bcf1be99ac5181f9434c33c81e}{program\+\_\+size} () const
\item 
{\footnotesize template$<$typename Grammar\+\_\+t $>$ }\\int \hyperlink{class_node_a2300ca04a56aeca14977915c4de0f53e}{linearize} (Program \&program) const
\item 
virtual bool \hyperlink{class_node_a8f42de356c047dd52472d24ace4d42c5}{operator==} (const \hyperlink{class_node}{Node} \&n) const override
\item 
virtual size\+\_\+t \hyperlink{class_node_a212f2e1ba4ff71de6954b0b791d89979}{hash} (size\+\_\+t depth=0) const
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const \hyperlink{class_rule}{Rule} $\ast$ \hyperlink{class_node_a02f5c9463cceb270ad5730760f19c722}{rule}
\item 
double \hyperlink{class_node_a298eaa3743b774a3f9ef396e1dc42a08}{lp}
\item 
bool \hyperlink{class_node_a98c14a51b240fbc7e438f40a12276257}{can\+\_\+resample}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const char \hyperlink{class_node_abd26102ffbe2a3e00c34bed5508b3234}{N\+T\+Delimiter} = \textquotesingle{}\+:\textquotesingle{}
\item 
static const char \hyperlink{class_node_ab58932e82964fb75ba806870c4069dc2}{Rule\+Delimiter} = \textquotesingle{};\textquotesingle{}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{class_node_ae875dded1044564c83cdc7147d86dfbf}{Base\+Node$<$ Node $>$}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_node_ae33050869651f64551da2d13ad2a9dbc}\label{class_node_ae33050869651f64551da2d13ad2a9dbc}} 
\index{Node@{Node}!Node@{Node}}
\index{Node@{Node}!Node@{Node}}
\subsubsection{\texorpdfstring{Node()}{Node()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily Node\+::\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{class_rule}{Rule} $\ast$}]{r = {\ttfamily nullptr},  }\item[{double}]{\+\_\+lp = {\ttfamily 0.0},  }\item[{bool}]{cr = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_a277918b68827f6ffd8150f450b0c12c3}\label{class_node_a277918b68827f6ffd8150f450b0c12c3}} 
\index{Node@{Node}!Node@{Node}}
\index{Node@{Node}!Node@{Node}}
\subsubsection{\texorpdfstring{Node()}{Node()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily Node\+::\+Node (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_a87c9938dcd77c169802a732c98204945}\label{class_node_a87c9938dcd77c169802a732c98204945}} 
\index{Node@{Node}!Node@{Node}}
\index{Node@{Node}!Node@{Node}}
\subsubsection{\texorpdfstring{Node()}{Node()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily Node\+::\+Node (\begin{DoxyParamCaption}\item[{\hyperlink{class_node}{Node} \&\&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_af5e3fa79300bf5f3f2f3ecae6e795a94}\label{class_node_af5e3fa79300bf5f3f2f3ecae6e795a94}} 
\index{Node@{Node}!````~Node@{$\sim$\+Node}}
\index{````~Node@{$\sim$\+Node}!Node@{Node}}
\subsubsection{\texorpdfstring{$\sim$\+Node()}{~Node()}}
{\footnotesize\ttfamily virtual Node\+::$\sim$\+Node (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_node_ac6f1a0f5274eae688c1959aecbfde2b0}\label{class_node_ac6f1a0f5274eae688c1959aecbfde2b0}} 
\index{Node@{Node}!all@{all}}
\index{all@{all}!Node@{Node}}
\subsubsection{\texorpdfstring{all()}{all()}}
{\footnotesize\ttfamily bool Node\+::all (\begin{DoxyParamCaption}\item[{std\+::function$<$ bool(const \hyperlink{class_node}{Node} \&)$>$ \&}]{f }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Check if f is true of me and every node below 
\begin{DoxyParams}{Parameters}
{\em f} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a9dde16ce87ed78ca8c49f8b4c3be42f3}\label{class_node_a9dde16ce87ed78ca8c49f8b4c3be42f3}} 
\index{Node@{Node}!count\+\_\+nonnull@{count\+\_\+nonnull}}
\index{count\+\_\+nonnull@{count\+\_\+nonnull}!Node@{Node}}
\subsubsection{\texorpdfstring{count\+\_\+nonnull()}{count\_nonnull()}}
{\footnotesize\ttfamily virtual size\+\_\+t Node\+::count\+\_\+nonnull (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

How many nodes total are below me? 
\begin{DoxyParams}{Parameters}
{\em n} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a212f2e1ba4ff71de6954b0b791d89979}\label{class_node_a212f2e1ba4ff71de6954b0b791d89979}} 
\index{Node@{Node}!hash@{hash}}
\index{hash@{hash}!Node@{Node}}
\subsubsection{\texorpdfstring{hash()}{hash()}}
{\footnotesize\ttfamily virtual size\+\_\+t Node\+::hash (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{depth = {\ttfamily 0} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Hash a tree by hashing the rule and everything below. 
\begin{DoxyParams}{Parameters}
{\em depth} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_ac2e36754ba8b1b1d452deeb2bdbd346f}\label{class_node_ac2e36754ba8b1b1d452deeb2bdbd346f}} 
\index{Node@{Node}!is\+\_\+complete@{is\+\_\+complete}}
\index{is\+\_\+complete@{is\+\_\+complete}!Node@{Node}}
\subsubsection{\texorpdfstring{is\+\_\+complete()}{is\_complete()}}
{\footnotesize\ttfamily virtual bool Node\+::is\+\_\+complete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

A tree is complete if it contains no null nodes below it. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a895ef3b66f975fbaec1e5866a57afbed}\label{class_node_a895ef3b66f975fbaec1e5866a57afbed}} 
\index{Node@{Node}!is\+\_\+null@{is\+\_\+null}}
\index{is\+\_\+null@{is\+\_\+null}!Node@{Node}}
\subsubsection{\texorpdfstring{is\+\_\+null()}{is\_null()}}
{\footnotesize\ttfamily bool Node\+::is\+\_\+null (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Am I a null node? \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a2300ca04a56aeca14977915c4de0f53e}\label{class_node_a2300ca04a56aeca14977915c4de0f53e}} 
\index{Node@{Node}!linearize@{linearize}}
\index{linearize@{linearize}!Node@{Node}}
\subsubsection{\texorpdfstring{linearize()}{linearize()}}
{\footnotesize\ttfamily template$<$typename Grammar\+\_\+t $>$ \\
int Node\+::linearize (\begin{DoxyParamCaption}\item[{Program \&}]{program }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

convert tree to a linear sequence of operations. To do this, we first linearize the kids, leaving their values as the top on the stack then we compute our value, remove our kids\textquotesingle{} values to clean up the stack, and push on our return the only fanciness is for if\+: here we will use the following layout $<$\+T\+O\+P of=\char`\"{}\char`\"{} stack$>$=\char`\"{}\char`\"{}$>$ $<$bool$>$ op\+\_\+\+I\+F(xsize) X-\/branch J\+U\+M\+P(ysize) Y-\/branch

N\+O\+TE\+: Inline here lets gcc inline a few recursions of this function, which ends up speeding us up a bit (otherwise recursive inlining only happens at -\/\+O3) This optimization is why we do set max-\/inline-\/insns-\/recursive in Fleet.\+mk 
\begin{DoxyParams}{Parameters}
{\em ops} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This returns the {\itshape size} of the program that was pushed onto ops. This is useful for saving us lots of calls to program\+\_\+size, which ends up being an important optimization.
\end{DoxyReturn}
\mbox{\Hypertarget{class_node_adefac3cb7b411321c5af15dad1484834}\label{class_node_adefac3cb7b411321c5af15dad1484834}} 
\index{Node@{Node}!map@{map}}
\index{map@{map}!Node@{Node}}
\subsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily void Node\+::map (\begin{DoxyParamCaption}\item[{const std\+::function$<$ void(\hyperlink{class_node}{Node} \&)$>$ \&}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Apply f to me and everything below. 
\begin{DoxyParams}{Parameters}
{\em f} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_node_a4abe3acdc804489a01ef13a25b130fd8}\label{class_node_a4abe3acdc804489a01ef13a25b130fd8}} 
\index{Node@{Node}!nt@{nt}}
\index{nt@{nt}!Node@{Node}}
\subsubsection{\texorpdfstring{nt()}{nt()}}
{\footnotesize\ttfamily \hyperlink{_nonterminal_8h_a1c5bfe9b903f69c83bbde5da7035fef3}{nonterminal\+\_\+t} Node\+::nt (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

What nonterminal type do I return? \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a8b05feb361beb04d465619751a2297b1}\label{class_node_a8b05feb361beb04d465619751a2297b1}} 
\index{Node@{Node}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!Node@{Node}}
\subsubsection{\texorpdfstring{operator$<$()}{operator<()}}
{\footnotesize\ttfamily bool Node\+::operator$<$ (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_addbfe90949f473c91203389f48095cf0}\label{class_node_addbfe90949f473c91203389f48095cf0}} 
\index{Node@{Node}!operator=@{operator=}}
\index{operator=@{operator=}!Node@{Node}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Node\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_abcd5c8ca2ea54716a72f7e27f9a9c937}\label{class_node_abcd5c8ca2ea54716a72f7e27f9a9c937}} 
\index{Node@{Node}!operator=@{operator=}}
\index{operator=@{operator=}!Node@{Node}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Node\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{class_node}{Node} \&\&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_a8f42de356c047dd52472d24ace4d42c5}\label{class_node_a8f42de356c047dd52472d24ace4d42c5}} 
\index{Node@{Node}!operator==@{operator==}}
\index{operator==@{operator==}!Node@{Node}}
\subsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily virtual bool Node\+::operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Check equality between notes. Note this compares rule objects. 
\begin{DoxyParams}{Parameters}
{\em n} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Reimplemented from \hyperlink{class_base_node_a33bb5c59122f6b2778d39a0eaa0151d7}{Base\+Node$<$ Node $>$}.

\mbox{\Hypertarget{class_node_a70e879ceb71f47787137572d9bee8efa}\label{class_node_a70e879ceb71f47787137572d9bee8efa}} 
\index{Node@{Node}!parseable@{parseable}}
\index{parseable@{parseable}!Node@{Node}}
\subsubsection{\texorpdfstring{parseable()}{parseable()}}
{\footnotesize\ttfamily virtual std\+::string Node\+::parseable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Create a string that can be parsed according to \hyperlink{class_grammar_acd13159e6ec71f73b5398ba5a56ac109}{Grammar.\+expand\+\_\+from\+\_\+names} \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a377548bcf1be99ac5181f9434c33c81e}\label{class_node_a377548bcf1be99ac5181f9434c33c81e}} 
\index{Node@{Node}!program\+\_\+size@{program\+\_\+size}}
\index{program\+\_\+size@{program\+\_\+size}!Node@{Node}}
\subsubsection{\texorpdfstring{program\+\_\+size()}{program\_size()}}
{\footnotesize\ttfamily virtual size\+\_\+t Node\+::program\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

How big of a program does this correspond to? This is mostly the number of nodes, except that short-\/circuit evaluation of IF makes things a little more complex. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_afff50c3712b8e30fffd479cad4eee023}\label{class_node_afff50c3712b8e30fffd479cad4eee023}} 
\index{Node@{Node}!set\+\_\+child@{set\+\_\+child}}
\index{set\+\_\+child@{set\+\_\+child}!Node@{Node}}
\subsubsection{\texorpdfstring{set\+\_\+child()}{set\_child()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Node\+::set\+\_\+child (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{i,  }\item[{\hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set my child to n. N\+O\+TE\+: This one needs to be used, rather than accessing children directly, because we have to set parent pointers and indices. 
\begin{DoxyParams}{Parameters}
{\em i} & \\
\hline
{\em n} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_node_a486882370d2c9592c6eabb52a3289253}\label{class_node_a486882370d2c9592c6eabb52a3289253}} 
\index{Node@{Node}!set\+\_\+child@{set\+\_\+child}}
\index{set\+\_\+child@{set\+\_\+child}!Node@{Node}}
\subsubsection{\texorpdfstring{set\+\_\+child()}{set\_child()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Node\+::set\+\_\+child (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{i,  }\item[{\hyperlink{class_node}{Node} \&\&}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set my child to n. N\+O\+TE\+: This one needs to be used, rather than accessing children directly, because we have to set parent pointers and indices. 
\begin{DoxyParams}{Parameters}
{\em i} & \\
\hline
{\em n} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_node_a5d2a0e17dd2a00a79e6d1f763c9114d0}\label{class_node_a5d2a0e17dd2a00a79e6d1f763c9114d0}} 
\index{Node@{Node}!string@{string}}
\index{string@{string}!Node@{Node}}
\subsubsection{\texorpdfstring{string()}{string()}}
{\footnotesize\ttfamily virtual std\+::string Node\+::string (\begin{DoxyParamCaption}\item[{bool}]{usedot = {\ttfamily true} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Convert a tree to a string, using each node\textquotesingle{}s format. 
\begin{DoxyParams}{Parameters}
{\em usedot} & -\/ do we print a dot in front of pieces of nodes that cannot be resampled? Useful for mcts \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Reimplemented from \hyperlink{class_base_node_a079dae7bec84f4de8eef6d6cb9368a22}{Base\+Node$<$ Node $>$}.

\mbox{\Hypertarget{class_node_ac91282056a0df2835f1579bdd21c93e1}\label{class_node_ac91282056a0df2835f1579bdd21c93e1}} 
\index{Node@{Node}!sum@{sum}}
\index{sum@{sum}!Node@{Node}}
\subsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T Node\+::sum (\begin{DoxyParamCaption}\item[{std\+::function$<$ T(const \hyperlink{class_node}{Node} \&)$>$ \&}]{f }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Apply f to me and everything below me, adding up the result. 
\begin{DoxyParams}{Parameters}
{\em f} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_node_a089e99addd93f91b2ef5a9d0c3e6bdeb}\label{class_node_a089e99addd93f91b2ef5a9d0c3e6bdeb}} 
\index{Node@{Node}!sum@{sum}}
\index{sum@{sum}!Node@{Node}}
\subsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T Node\+::sum (\begin{DoxyParamCaption}\item[{T($\ast$)(const \hyperlink{class_node}{Node} \&)}]{f }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_node_aa727c354e38f60fb1560d72ae1aaa9af}\label{class_node_aa727c354e38f60fb1560d72ae1aaa9af}} 
\index{Node@{Node}!type@{type}}
\index{type@{type}!Node@{Node}}
\subsubsection{\texorpdfstring{type()}{type()}}
{\footnotesize\ttfamily \hyperlink{_nonterminal_8h_a1c5bfe9b903f69c83bbde5da7035fef3}{nonterminal\+\_\+t} Node\+::type (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{i }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the type of the i\textquotesingle{}th child 
\begin{DoxyParams}{Parameters}
{\em i} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


\subsection{Friends And Related Function Documentation}
\mbox{\Hypertarget{class_node_ae875dded1044564c83cdc7147d86dfbf}\label{class_node_ae875dded1044564c83cdc7147d86dfbf}} 
\index{Node@{Node}!Base\+Node$<$ Node $>$@{Base\+Node$<$ Node $>$}}
\index{Base\+Node$<$ Node $>$@{Base\+Node$<$ Node $>$}!Node@{Node}}
\subsubsection{\texorpdfstring{Base\+Node$<$ Node $>$}{BaseNode< Node >}}
{\footnotesize\ttfamily friend class \hyperlink{class_base_node}{Base\+Node}$<$ \hyperlink{class_node}{Node} $>$\hspace{0.3cm}{\ttfamily [friend]}}



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_node_a98c14a51b240fbc7e438f40a12276257}\label{class_node_a98c14a51b240fbc7e438f40a12276257}} 
\index{Node@{Node}!can\+\_\+resample@{can\+\_\+resample}}
\index{can\+\_\+resample@{can\+\_\+resample}!Node@{Node}}
\subsubsection{\texorpdfstring{can\+\_\+resample}{can\_resample}}
{\footnotesize\ttfamily bool Node\+::can\+\_\+resample}

\mbox{\Hypertarget{class_node_a298eaa3743b774a3f9ef396e1dc42a08}\label{class_node_a298eaa3743b774a3f9ef396e1dc42a08}} 
\index{Node@{Node}!lp@{lp}}
\index{lp@{lp}!Node@{Node}}
\subsubsection{\texorpdfstring{lp}{lp}}
{\footnotesize\ttfamily double Node\+::lp}

\mbox{\Hypertarget{class_node_abd26102ffbe2a3e00c34bed5508b3234}\label{class_node_abd26102ffbe2a3e00c34bed5508b3234}} 
\index{Node@{Node}!N\+T\+Delimiter@{N\+T\+Delimiter}}
\index{N\+T\+Delimiter@{N\+T\+Delimiter}!Node@{Node}}
\subsubsection{\texorpdfstring{N\+T\+Delimiter}{NTDelimiter}}
{\footnotesize\ttfamily const char Node\+::\+N\+T\+Delimiter = \textquotesingle{}\+:\textquotesingle{}\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{class_node_a02f5c9463cceb270ad5730760f19c722}\label{class_node_a02f5c9463cceb270ad5730760f19c722}} 
\index{Node@{Node}!rule@{rule}}
\index{rule@{rule}!Node@{Node}}
\subsubsection{\texorpdfstring{rule}{rule}}
{\footnotesize\ttfamily const \hyperlink{class_rule}{Rule}$\ast$ Node\+::rule}

\mbox{\Hypertarget{class_node_ab58932e82964fb75ba806870c4069dc2}\label{class_node_ab58932e82964fb75ba806870c4069dc2}} 
\index{Node@{Node}!Rule\+Delimiter@{Rule\+Delimiter}}
\index{Rule\+Delimiter@{Rule\+Delimiter}!Node@{Node}}
\subsubsection{\texorpdfstring{Rule\+Delimiter}{RuleDelimiter}}
{\footnotesize\ttfamily const char Node\+::\+Rule\+Delimiter = \textquotesingle{};\textquotesingle{}\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Grammar/\hyperlink{_node_8h}{Node.\+h}\end{DoxyCompactItemize}
