\hypertarget{namespace_proposals}{}\section{Proposals Namespace Reference}
\label{namespace_proposals}\index{Proposals@{Proposals}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
double \hyperlink{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}{can\+\_\+resample} (const \hyperlink{class_node}{Node} \&n)
\item 
{\footnotesize template$<$typename Grammar\+Type $>$ }\\std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_add01a544339cc3713d02f663c331f33b}{prior\+\_\+proposal} (Grammar\+Type $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
{\footnotesize template$<$typename Grammar\+Type $>$ }\\std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_aedcca10b4519a9aad7739878036019f3}{regenerate} (Grammar\+Type $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
{\footnotesize template$<$typename Grammar\+Type $>$ }\\std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a8714ac1333d5aff2d248ef10a8eb5493}{insert\+\_\+tree} (Grammar\+Type $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\item 
{\footnotesize template$<$typename Grammar\+Type $>$ }\\std\+::pair$<$ \hyperlink{class_node}{Node}, double $>$ \hyperlink{namespace_proposals_a785ec0b4f2f5df9b78bbb8c0c5f16118}{delete\+\_\+tree} (Grammar\+Type $\ast$grammar, const \hyperlink{class_node}{Node} \&from)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}\label{namespace_proposals_a73f20ef1547bc5beef3e6e3adad2139c}} 
\index{Proposals@{Proposals}!can\+\_\+resample@{can\+\_\+resample}}
\index{can\+\_\+resample@{can\+\_\+resample}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{can\+\_\+resample()}{can\_resample()}}
{\footnotesize\ttfamily double Proposals\+::can\+\_\+resample (\begin{DoxyParamCaption}\item[{const \hyperlink{class_node}{Node} \&}]{n }\end{DoxyParamCaption})}

Helper function for whether we can resample from a node (just accesses n.\+can\+\_\+resample) 
\begin{DoxyParams}{Parameters}
{\em n} & -\/ what node are we asking about? \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
-\/ a double (1.\+0 or 0.\+0) depending on whether n can be sampled
\end{DoxyReturn}
\mbox{\Hypertarget{namespace_proposals_a785ec0b4f2f5df9b78bbb8c0c5f16118}\label{namespace_proposals_a785ec0b4f2f5df9b78bbb8c0c5f16118}} 
\index{Proposals@{Proposals}!delete\+\_\+tree@{delete\+\_\+tree}}
\index{delete\+\_\+tree@{delete\+\_\+tree}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{delete\+\_\+tree()}{delete\_tree()}}
{\footnotesize\ttfamily template$<$typename Grammar\+Type $>$ \\
std\+::pair$<$\hyperlink{class_node}{Node}, double$>$ Proposals\+::delete\+\_\+tree (\begin{DoxyParamCaption}\item[{Grammar\+Type $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

backward is we choose the {\itshape new} s, then generate everything else, and choose anything equal \mbox{\Hypertarget{namespace_proposals_a8714ac1333d5aff2d248ef10a8eb5493}\label{namespace_proposals_a8714ac1333d5aff2d248ef10a8eb5493}} 
\index{Proposals@{Proposals}!insert\+\_\+tree@{insert\+\_\+tree}}
\index{insert\+\_\+tree@{insert\+\_\+tree}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{insert\+\_\+tree()}{insert\_tree()}}
{\footnotesize\ttfamily template$<$typename Grammar\+Type $>$ \\
std\+::pair$<$\hyperlink{class_node}{Node}, double$>$ Proposals\+::insert\+\_\+tree (\begin{DoxyParamCaption}\item[{Grammar\+Type $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

backward is we choose t exactly, then we pick anything below that is equal to s \mbox{\Hypertarget{namespace_proposals_add01a544339cc3713d02f663c331f33b}\label{namespace_proposals_add01a544339cc3713d02f663c331f33b}} 
\index{Proposals@{Proposals}!prior\+\_\+proposal@{prior\+\_\+proposal}}
\index{prior\+\_\+proposal@{prior\+\_\+proposal}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{prior\+\_\+proposal()}{prior\_proposal()}}
{\footnotesize\ttfamily template$<$typename Grammar\+Type $>$ \\
std\+::pair$<$\hyperlink{class_node}{Node},double$>$ Proposals\+::prior\+\_\+proposal (\begin{DoxyParamCaption}\item[{Grammar\+Type $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespace_proposals_aedcca10b4519a9aad7739878036019f3}\label{namespace_proposals_aedcca10b4519a9aad7739878036019f3}} 
\index{Proposals@{Proposals}!regenerate@{regenerate}}
\index{regenerate@{regenerate}!Proposals@{Proposals}}
\subsubsection{\texorpdfstring{regenerate()}{regenerate()}}
{\footnotesize\ttfamily template$<$typename Grammar\+Type $>$ \\
std\+::pair$<$\hyperlink{class_node}{Node},double$>$ Proposals\+::regenerate (\begin{DoxyParamCaption}\item[{Grammar\+Type $\ast$}]{grammar,  }\item[{const \hyperlink{class_node}{Node} \&}]{from }\end{DoxyParamCaption})}

Regenerate with a rational-\/rules (Goodman et al.) style regeneration proposal\+: pick a node uniformly and regenerate it from the grammar. 
\begin{DoxyParams}{Parameters}
{\em grammar} & -\/ what grammar to use \\
\hline
{\em from} & -\/ what node are we proposing from \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pair of the new proposed tree and the forward-\/backward log probability (for use in M\+C\+MC)
\end{DoxyReturn}
