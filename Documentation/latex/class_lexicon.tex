\hypertarget{class_lexicon}{}\section{Lexicon$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$ Class Template Reference}
\label{class_lexicon}\index{Lexicon$<$ this\+\_\+t, I\+N\+N\+E\+R, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$@{Lexicon$<$ this\+\_\+t, I\+N\+N\+E\+R, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$}}


{\ttfamily \#include $<$Lexicon.\+h$>$}



Inheritance diagram for Lexicon$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_lexicon__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Lexicon$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_lexicon__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{class_lexicon_aad6ccf985be61e5386ea67f0f7670d65}{Virtual\+Machine\+State\+\_\+t} = \+\_\+\+Virtual\+Machine\+State\+\_\+t
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_lexicon_a953fa0e2f69d1b72fa567a09f80ef73c}{Lexicon} (size\+\_\+t n)
\item 
\hyperlink{class_lexicon_a60ed551d9c6a52e18f1e8668b89a6fa5}{Lexicon} ()
\item 
size\+\_\+t \hyperlink{class_lexicon_af83fbb93bd5ef30a39997c855ce2b0f5}{nfactors} () const
\item 
virtual std\+::string \hyperlink{class_lexicon_a94d839ba9055b7a8e859628828939ffb}{string} (std\+::string prefix=\char`\"{}\char`\"{}) const override
\item 
virtual std\+::string \hyperlink{class_lexicon_aee7952473269abe7fc1cc0e2b96b8307}{parseable} () const
\item 
virtual size\+\_\+t \hyperlink{class_lexicon_a53dc77a82e9cb0312ef3de53f0a65b0a}{hash} () const override
\begin{DoxyCompactList}\small\item\em Default hash function. \end{DoxyCompactList}\item 
virtual bool \hyperlink{class_lexicon_a04bde89f87b53ea3b283149f159dd35f}{operator==} (const this\+\_\+t \&l) const override
\item 
bool \hyperlink{class_lexicon_aa9200d0476bd5016e7ea1f049738ed47}{has\+\_\+valid\+\_\+indices} () const
\item 
bool \hyperlink{class_lexicon_a4d2056453bb4fdd179c0e961fb071aea}{check\+\_\+reachable} () const
\item 
virtual size\+\_\+t \hyperlink{class_lexicon_a25f1c33df93b2e0722bc5c0f3b37ebcd}{program\+\_\+size} (short s) override
\item 
virtual void \hyperlink{class_lexicon_a16462025a8be6ffff655b27c84b4307d}{push\+\_\+program} (Program \&s, short j) override
\item 
virtual void \hyperlink{class_lexicon_a881ff3280b54f56b88d2511e319b5a4d}{complete} () override
\begin{DoxyCompactList}\small\item\em Fill in all the holes in this hypothesis, at random, modifying self. \end{DoxyCompactList}\item 
virtual double \hyperlink{class_lexicon_a73e4205ac7b0e6f4f207e5d71dea1910}{compute\+\_\+prior} () override
\begin{DoxyCompactList}\small\item\em Compute the prior -- defaultly not defined. \end{DoxyCompactList}\item 
virtual std\+::pair$<$ this\+\_\+t, double $>$ \hyperlink{class_lexicon_a55ee8238cd46ef0ffcefe46ba9af47e2}{propose} () const override
\item 
virtual this\+\_\+t \hyperlink{class_lexicon_af78f84c26c2b3593c505388a45ba6d19}{restart} () const override
\item 
int \hyperlink{class_lexicon_ae6f2b66da71145d0e8983951513b994c}{neighbors} () const override
\begin{DoxyCompactList}\small\item\em Count the number of neighbors that are possible. (This should be size\+\_\+t but int is more convenient.) \end{DoxyCompactList}\item 
void \hyperlink{class_lexicon_a283893cb37705bd6421fb3a1dc94432f}{expand\+\_\+to\+\_\+neighbor} (int k) override
\begin{DoxyCompactList}\small\item\em Modify this hypothesis to become the k\textquotesingle{}th neighbor. \end{DoxyCompactList}\item 
virtual double \hyperlink{class_lexicon_ac4cb2e1a2db91e0aa8984aa5aaad70a9}{neighbor\+\_\+prior} (int k) override
\begin{DoxyCompactList}\small\item\em What is the prior of the k\textquotesingle{}th neighbor? This does not need to return the full prior, only relative (among ks) \end{DoxyCompactList}\item 
bool \hyperlink{class_lexicon_a7742f252ea9909f12071b5af500310cf}{is\+\_\+evaluable} () const override
\begin{DoxyCompactList}\small\item\em Can this be evalutaed (really should be named -- can be called?). Sometimes partial hypotheses can\textquotesingle{}t be called. \end{DoxyCompactList}\item 
virtual \hyperlink{class_discrete_distribution}{Discrete\+Distribution}$<$ output\+\_\+t $>$ \hyperlink{class_lexicon_a622f63b82d7056564f2c03ec4d599c91}{call} (const input\+\_\+t x, const output\+\_\+t err=output\+\_\+t\{\}, \hyperlink{class_program_loader}{Program\+Loader} $\ast$loader=nullptr) override
\begin{DoxyCompactList}\small\item\em Run the virtual machine on input x, and marginalize over execution paths to return a distribution on outputs. Note that loader must be a program loader, and that is to handle recursion and other function calls. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Grammar\+Type $>$ }\\static this\+\_\+t \hyperlink{class_lexicon_ae3ccf40adf7f3b6337bfe9728a551fc0}{from\+\_\+string} (Grammar\+Type \&g, std\+::string s)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ I\+N\+N\+ER $>$ \hyperlink{class_lexicon_ac502a88f9e4e38c18c74fa8d039cfe1e}{factors}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const char \hyperlink{class_lexicon_abf0f7108f95fdb5d3d66a9bc88a8d04d}{Factor\+Delimiter} = \textquotesingle{}$\vert$\textquotesingle{}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename this\+\_\+t, typename I\+N\+N\+ER, typename input\+\_\+t, typename output\+\_\+t, typename datum\+\_\+t = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$\newline
class Lexicon$<$ this\+\_\+t, I\+N\+N\+E\+R, input\+\_\+t, output\+\_\+t, datum\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$}

\begin{DoxyAuthor}{Author}
piantado 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
29/01/20 
\end{DoxyDate}


\subsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_lexicon_aad6ccf985be61e5386ea67f0f7670d65}\label{class_lexicon_aad6ccf985be61e5386ea67f0f7670d65}} 
\index{Lexicon@{Lexicon}!Virtual\+Machine\+State\+\_\+t@{Virtual\+Machine\+State\+\_\+t}}
\index{Virtual\+Machine\+State\+\_\+t@{Virtual\+Machine\+State\+\_\+t}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{Virtual\+Machine\+State\+\_\+t}{VirtualMachineState\_t}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
using \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::\hyperlink{class_lexicon_aad6ccf985be61e5386ea67f0f7670d65}{Virtual\+Machine\+State\+\_\+t} =  \+\_\+\+Virtual\+Machine\+State\+\_\+t}



\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_lexicon_a953fa0e2f69d1b72fa567a09f80ef73c}\label{class_lexicon_a953fa0e2f69d1b72fa567a09f80ef73c}} 
\index{Lexicon@{Lexicon}!Lexicon@{Lexicon}}
\index{Lexicon@{Lexicon}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{Lexicon()}{Lexicon()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
\hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::\hyperlink{class_lexicon}{Lexicon} (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_lexicon_a60ed551d9c6a52e18f1e8668b89a6fa5}\label{class_lexicon_a60ed551d9c6a52e18f1e8668b89a6fa5}} 
\index{Lexicon@{Lexicon}!Lexicon@{Lexicon}}
\index{Lexicon@{Lexicon}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{Lexicon()}{Lexicon()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
\hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::\hyperlink{class_lexicon}{Lexicon} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_lexicon_a622f63b82d7056564f2c03ec4d599c91}\label{class_lexicon_a622f63b82d7056564f2c03ec4d599c91}} 
\index{Lexicon@{Lexicon}!call@{call}}
\index{call@{call}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{call()}{call()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual \hyperlink{class_discrete_distribution}{Discrete\+Distribution}$<$output\+\_\+t$>$ \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::call (\begin{DoxyParamCaption}\item[{const input\+\_\+t}]{x,  }\item[{const output\+\_\+t}]{err = {\ttfamily output\+\_\+t\{\}},  }\item[{\hyperlink{class_program_loader}{Program\+Loader} $\ast$}]{loader = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Run the virtual machine on input x, and marginalize over execution paths to return a distribution on outputs. Note that loader must be a program loader, and that is to handle recursion and other function calls. 


\begin{DoxyParams}{Parameters}
{\em x} & -\/ input \\
\hline
{\em err} & -\/ output value on error \\
\hline
{\em loader} & -\/ where to load recursive calls \\
\hline
{\em max\+\_\+steps} & -\/ max steps the virtual machine pool will run for \\
\hline
{\em max\+\_\+outputs} & -\/ max outputs the virtual machine pool will run for \\
\hline
{\em minlp} & -\/ the virtual machine pool doesn\textquotesingle{}t consider paths less than this probability \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Reimplemented from \hyperlink{class_callable_af10dbf87425f03b7153f8ec230bf9116}{Callable$<$ input\+\_\+t, output\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_a4d2056453bb4fdd179c0e961fb071aea}\label{class_lexicon_a4d2056453bb4fdd179c0e961fb071aea}} 
\index{Lexicon@{Lexicon}!check\+\_\+reachable@{check\+\_\+reachable}}
\index{check\+\_\+reachable@{check\+\_\+reachable}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{check\+\_\+reachable()}{check\_reachable()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
bool \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::check\+\_\+reachable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Check if the last factor call everything else transitively (e.\+g. are we \char`\"{}wasting\char`\"{} factors) We do this by making a graph of what factors call which others and then computing the transitive closure. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_lexicon_a881ff3280b54f56b88d2511e319b5a4d}\label{class_lexicon_a881ff3280b54f56b88d2511e319b5a4d}} 
\index{Lexicon@{Lexicon}!complete@{complete}}
\index{complete@{complete}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{complete()}{complete()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual void \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::complete (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Fill in all the holes in this hypothesis, at random, modifying self. 



Implements \hyperlink{class_searchable_a29ab2eb0471e2e9d96d39f0349f21571}{Searchable$<$ this\+\_\+t, input\+\_\+t, output\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_a73e4205ac7b0e6f4f207e5d71dea1910}\label{class_lexicon_a73e4205ac7b0e6f4f207e5d71dea1910}} 
\index{Lexicon@{Lexicon}!compute\+\_\+prior@{compute\+\_\+prior}}
\index{compute\+\_\+prior@{compute\+\_\+prior}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{compute\+\_\+prior()}{compute\_prior()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual double \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::compute\+\_\+prior (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Compute the prior -- defaultly not defined. 



Implements \hyperlink{class_bayesable_a1b057a17212ced123545133e2297c01b}{Bayesable$<$ Args... $>$}.

\mbox{\Hypertarget{class_lexicon_a283893cb37705bd6421fb3a1dc94432f}\label{class_lexicon_a283893cb37705bd6421fb3a1dc94432f}} 
\index{Lexicon@{Lexicon}!expand\+\_\+to\+\_\+neighbor@{expand\+\_\+to\+\_\+neighbor}}
\index{expand\+\_\+to\+\_\+neighbor@{expand\+\_\+to\+\_\+neighbor}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{expand\+\_\+to\+\_\+neighbor()}{expand\_to\_neighbor()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
void \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::expand\+\_\+to\+\_\+neighbor (\begin{DoxyParamCaption}\item[{int}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Modify this hypothesis to become the k\textquotesingle{}th neighbor. 


\begin{DoxyParams}{Parameters}
{\em k} & \\
\hline
\end{DoxyParams}


Implements \hyperlink{class_searchable_a9088dba3920f4c66ce671aa16a7d29a4}{Searchable$<$ this\+\_\+t, input\+\_\+t, output\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_ae3ccf40adf7f3b6337bfe9728a551fc0}\label{class_lexicon_ae3ccf40adf7f3b6337bfe9728a551fc0}} 
\index{Lexicon@{Lexicon}!from\+\_\+string@{from\+\_\+string}}
\index{from\+\_\+string@{from\+\_\+string}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{from\+\_\+string()}{from\_string()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
template$<$typename Grammar\+Type $>$ \\
static this\+\_\+t \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::from\+\_\+string (\begin{DoxyParamCaption}\item[{Grammar\+Type \&}]{g,  }\item[{std\+::string}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Convert a string to a lexicon of this type 
\begin{DoxyParams}{Parameters}
{\em g} & \\
\hline
{\em s} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_lexicon_aa9200d0476bd5016e7ea1f049738ed47}\label{class_lexicon_aa9200d0476bd5016e7ea1f049738ed47}} 
\index{Lexicon@{Lexicon}!has\+\_\+valid\+\_\+indices@{has\+\_\+valid\+\_\+indices}}
\index{has\+\_\+valid\+\_\+indices@{has\+\_\+valid\+\_\+indices}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{has\+\_\+valid\+\_\+indices()}{has\_valid\_indices()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
bool \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::has\+\_\+valid\+\_\+indices (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

A lexicon has valid indices if calls to op\+\_\+\+R\+E\+C\+U\+R\+SE, op\+\_\+\+M\+E\+M\+\_\+\+R\+E\+C\+U\+R\+SE, op\+\_\+\+S\+A\+F\+E\+\_\+\+R\+E\+C\+U\+R\+SE, and op\+\_\+\+S\+A\+F\+E\+\_\+\+M\+E\+M\+\_\+\+R\+E\+C\+U\+R\+SE all have arguments that are less than the size. (So this places no restrictions on the calling earlier factors) \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_lexicon_a53dc77a82e9cb0312ef3de53f0a65b0a}\label{class_lexicon_a53dc77a82e9cb0312ef3de53f0a65b0a}} 
\index{Lexicon@{Lexicon}!hash@{hash}}
\index{hash@{hash}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{hash()}{hash()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual size\+\_\+t \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::hash (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Default hash function. 

Hash a \hyperlink{class_lexicon}{Lexicon} by hashing each part \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{class_bayesable_a26f6d55e7526ebd897cbb27c757b611b}{Bayesable$<$ Args... $>$}.

\mbox{\Hypertarget{class_lexicon_a7742f252ea9909f12071b5af500310cf}\label{class_lexicon_a7742f252ea9909f12071b5af500310cf}} 
\index{Lexicon@{Lexicon}!is\+\_\+evaluable@{is\+\_\+evaluable}}
\index{is\+\_\+evaluable@{is\+\_\+evaluable}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{is\+\_\+evaluable()}{is\_evaluable()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
bool \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::is\+\_\+evaluable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Can this be evalutaed (really should be named -- can be called?). Sometimes partial hypotheses can\textquotesingle{}t be called. 



Implements \hyperlink{class_callable_ac05ae8491f3b90986b1ad016da412afa}{Callable$<$ input\+\_\+t, output\+\_\+t, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_ac4cb2e1a2db91e0aa8984aa5aaad70a9}\label{class_lexicon_ac4cb2e1a2db91e0aa8984aa5aaad70a9}} 
\index{Lexicon@{Lexicon}!neighbor\+\_\+prior@{neighbor\+\_\+prior}}
\index{neighbor\+\_\+prior@{neighbor\+\_\+prior}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{neighbor\+\_\+prior()}{neighbor\_prior()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual double \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::neighbor\+\_\+prior (\begin{DoxyParamCaption}\item[{int}]{k }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



What is the prior of the k\textquotesingle{}th neighbor? This does not need to return the full prior, only relative (among ks) 


\begin{DoxyParams}{Parameters}
{\em k} & \\
\hline
\end{DoxyParams}


Implements \hyperlink{class_searchable_aa6f72073717a4df0d22c73705555b13a}{Searchable$<$ this\+\_\+t, input\+\_\+t, output\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_ae6f2b66da71145d0e8983951513b994c}\label{class_lexicon_ae6f2b66da71145d0e8983951513b994c}} 
\index{Lexicon@{Lexicon}!neighbors@{neighbors}}
\index{neighbors@{neighbors}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{neighbors()}{neighbors()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
int \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::neighbors (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Count the number of neighbors that are possible. (This should be size\+\_\+t but int is more convenient.) 



Implements \hyperlink{class_searchable_a68819cd23119615baa51d65451765c74}{Searchable$<$ this\+\_\+t, input\+\_\+t, output\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_af83fbb93bd5ef30a39997c855ce2b0f5}\label{class_lexicon_af83fbb93bd5ef30a39997c855ce2b0f5}} 
\index{Lexicon@{Lexicon}!nfactors@{nfactors}}
\index{nfactors@{nfactors}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{nfactors()}{nfactors()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
size\+\_\+t \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::nfactors (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{class_lexicon_a04bde89f87b53ea3b283149f159dd35f}\label{class_lexicon_a04bde89f87b53ea3b283149f159dd35f}} 
\index{Lexicon@{Lexicon}!operator==@{operator==}}
\index{operator==@{operator==}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual bool \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::operator== (\begin{DoxyParamCaption}\item[{const this\+\_\+t \&}]{l }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Equality checks equality on each part 
\begin{DoxyParams}{Parameters}
{\em l} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{class_m_c_m_cable_a7b35c04d3d1326b930cfc69dfe0bd207}{M\+C\+M\+Cable$<$ this\+\_\+t, datum\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_aee7952473269abe7fc1cc0e2b96b8307}\label{class_lexicon_aee7952473269abe7fc1cc0e2b96b8307}} 
\index{Lexicon@{Lexicon}!parseable@{parseable}}
\index{parseable@{parseable}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{parseable()}{parseable()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual std\+::string \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::parseable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Convert to a parseable format (using a delimiter for each factor) \begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{class_lexicon_a25f1c33df93b2e0722bc5c0f3b37ebcd}\label{class_lexicon_a25f1c33df93b2e0722bc5c0f3b37ebcd}} 
\index{Lexicon@{Lexicon}!program\+\_\+size@{program\+\_\+size}}
\index{program\+\_\+size@{program\+\_\+size}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{program\+\_\+size()}{program\_size()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual size\+\_\+t \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::program\+\_\+size (\begin{DoxyParamCaption}\item[{short}]{s }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \hyperlink{class_program_loader_a9485aaa6c23687131ed902f88c4f5731}{Program\+Loader}.

\mbox{\Hypertarget{class_lexicon_a55ee8238cd46ef0ffcefe46ba9af47e2}\label{class_lexicon_a55ee8238cd46ef0ffcefe46ba9af47e2}} 
\index{Lexicon@{Lexicon}!propose@{propose}}
\index{propose@{propose}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{propose()}{propose()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual std\+::pair$<$this\+\_\+t,double$>$ \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::propose (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

This proposal guarantees that there will be at least one factor that is proposed to. To do this, we draw random numbers on 2$\ast$$\ast$factors.size()-\/1 and then use the bits of that integer to determine which factors to propose to. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{class_m_c_m_cable_a98b52f1867ea0d72c1c91b4496d756d2}{M\+C\+M\+Cable$<$ this\+\_\+t, datum\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_a16462025a8be6ffff655b27c84b4307d}\label{class_lexicon_a16462025a8be6ffff655b27c84b4307d}} 
\index{Lexicon@{Lexicon}!push\+\_\+program@{push\+\_\+program}}
\index{push\+\_\+program@{push\+\_\+program}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{push\+\_\+program()}{push\_program()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual void \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::push\+\_\+program (\begin{DoxyParamCaption}\item[{Program \&}]{s,  }\item[{short}]{j }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Put factor j onto program s 
\begin{DoxyParams}{Parameters}
{\em s} & \\
\hline
{\em j} & \\
\hline
\end{DoxyParams}


Implements \hyperlink{class_program_loader_a68b234befb88579aaeeeed52414f9bd1}{Program\+Loader}.

\mbox{\Hypertarget{class_lexicon_af78f84c26c2b3593c505388a45ba6d19}\label{class_lexicon_af78f84c26c2b3593c505388a45ba6d19}} 
\index{Lexicon@{Lexicon}!restart@{restart}}
\index{restart@{restart}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{restart()}{restart()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual this\+\_\+t \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::restart (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}



Implements \hyperlink{class_m_c_m_cable_aa7017e18b4a1508bc4cff90fb82a8ec1}{M\+C\+M\+Cable$<$ this\+\_\+t, datum\+\_\+t $>$}.

\mbox{\Hypertarget{class_lexicon_a94d839ba9055b7a8e859628828939ffb}\label{class_lexicon_a94d839ba9055b7a8e859628828939ffb}} 
\index{Lexicon@{Lexicon}!string@{string}}
\index{string@{string}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{string()}{string()}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
virtual std\+::string \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::string (\begin{DoxyParamCaption}\item[{std\+::string}]{prefix = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

A\+Convert a lexicon to a string -- defaultly includes all arguments. \begin{DoxyReturn}{Returns}

\end{DoxyReturn}


Implements \hyperlink{class_bayesable_ab6944b4bfe5620c96048287a51d019c1}{Bayesable$<$ Args... $>$}.



\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_lexicon_abf0f7108f95fdb5d3d66a9bc88a8d04d}\label{class_lexicon_abf0f7108f95fdb5d3d66a9bc88a8d04d}} 
\index{Lexicon@{Lexicon}!Factor\+Delimiter@{Factor\+Delimiter}}
\index{Factor\+Delimiter@{Factor\+Delimiter}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{Factor\+Delimiter}{FactorDelimiter}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
const char \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::Factor\+Delimiter = \textquotesingle{}$\vert$\textquotesingle{}\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{class_lexicon_ac502a88f9e4e38c18c74fa8d039cfe1e}\label{class_lexicon_ac502a88f9e4e38c18c74fa8d039cfe1e}} 
\index{Lexicon@{Lexicon}!factors@{factors}}
\index{factors@{factors}!Lexicon@{Lexicon}}
\subsubsection{\texorpdfstring{factors}{factors}}
{\footnotesize\ttfamily template$<$typename this\+\_\+t , typename I\+N\+N\+ER , typename input\+\_\+t , typename output\+\_\+t , typename datum\+\_\+t  = defaultdatum\+\_\+t$<$input\+\_\+t, output\+\_\+t$>$, typename \+\_\+\+Virtual\+Machine\+State\+\_\+t  = typename I\+N\+N\+E\+R\+::\+Grammar\+\_\+t\+::\+Virtual\+Machine\+State\+\_\+t$>$ \\
std\+::vector$<$I\+N\+N\+ER$>$ \hyperlink{class_lexicon}{Lexicon}$<$ this\+\_\+t, I\+N\+N\+ER, input\+\_\+t, output\+\_\+t, \hyperlink{class_bayesable_a9f1a6c0cd7855550fa10b1a8f13a5867}{datum\+\_\+t}, \+\_\+\+Virtual\+Machine\+State\+\_\+t $>$\+::factors}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/\+Hypotheses/\hyperlink{_lexicon_8h}{Lexicon.\+h}\end{DoxyCompactItemize}
