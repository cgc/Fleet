\hypertarget{_vectors_8h}{}\doxysection{src/\+Containers/\+Vectors.h File Reference}
\label{_vectors_8h}\index{src/Containers/Vectors.h@{src/Containers/Vectors.h}}
{\ttfamily \#include $<$vector$>$}\newline
Include dependency graph for Vectors.\+h\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=215pt]{_vectors_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_vectors_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{_vectors_8h_ae11572812e4ad802473804201cc473f1}{slice}} (const std\+::vector$<$ T $>$ \&v, const size\+\_\+t start, const int len)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ \mbox{\hyperlink{_vectors_8h_a24e2169af51574ac00dcbbca1d7da55b}{slice}} (const std\+::vector$<$ T $>$ \&v, const size\+\_\+t start)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{_vectors_8h_aa96585fa2a4daa3b21c97b26a937f653}{increment}} (std\+::vector$<$ T $>$ \&v, const size\+\_\+t idx, T \mbox{\hyperlink{_strings_8h_ae6eafa3700b097b96c1601a141a45de4}{count}}=1)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{_vectors_8h_a81e872a75b38d3d09b6dd7b724ed940a}{glom}} (std\+::vector$<$ std\+::vector$<$ T $>$ $\ast$ $>$ \&X, std\+::vector$<$ T $>$ $\ast$\&v)
\begin{DoxyCompactList}\small\item\em Glom here takes a vector of pointers to vectors. It searches through X to find if anything matches the beginning of v, and if so, it will append the additional elements, and use the existing data. It then M\+O\+D\+I\+F\+I\+ES the v pointer (which is passed by reference). If no match can be found, glom will append v into x. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_vectors_8h_a81e872a75b38d3d09b6dd7b724ed940a}\label{_vectors_8h_a81e872a75b38d3d09b6dd7b724ed940a}} 
\index{Vectors.h@{Vectors.h}!glom@{glom}}
\index{glom@{glom}!Vectors.h@{Vectors.h}}
\doxysubsubsection{\texorpdfstring{glom()}{glom()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void glom (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ T $>$ $\ast$ $>$ \&}]{X,  }\item[{std\+::vector$<$ T $>$ $\ast$\&}]{v }\end{DoxyParamCaption})}



Glom here takes a vector of pointers to vectors. It searches through X to find if anything matches the beginning of v, and if so, it will append the additional elements, and use the existing data. It then M\+O\+D\+I\+F\+I\+ES the v pointer (which is passed by reference). If no match can be found, glom will append v into x. 

Thus, at the end of this, v points to something in X, but preferentially re-\/uses data in X. This is especially useful when we\textquotesingle{}re compiling incremental data for learning models.

N\+O\+TE\+: that sizes must be stored externally, since if a vector is stored in here, it may be appended to (so whatever is using X can\textquotesingle{}t just compute the size)

This is used primarily for Grammar\+Hypothesis storage of M\+C\+MC data, where we want to load multiple datasets and share overlap whenever possible (so we don\textquotesingle{}t duplicate M\+C\+MC sampling)


\begin{DoxyParams}{Parameters}
{\em X} & \\
\hline
{\em v} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
This returns a (possibly) new pointer for v. That is, it will either leave v unchanged or it will point to something in x 
\end{DoxyReturn}
\mbox{\Hypertarget{_vectors_8h_aa96585fa2a4daa3b21c97b26a937f653}\label{_vectors_8h_aa96585fa2a4daa3b21c97b26a937f653}} 
\index{Vectors.h@{Vectors.h}!increment@{increment}}
\index{increment@{increment}!Vectors.h@{Vectors.h}}
\doxysubsubsection{\texorpdfstring{increment()}{increment()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void increment (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{const size\+\_\+t}]{idx,  }\item[{T}]{count = {\ttfamily 1} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_vectors_8h_a24e2169af51574ac00dcbbca1d7da55b}\label{_vectors_8h_a24e2169af51574ac00dcbbca1d7da55b}} 
\index{Vectors.h@{Vectors.h}!slice@{slice}}
\index{slice@{slice}!Vectors.h@{Vectors.h}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$T$>$ slice (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{const size\+\_\+t}]{start }\end{DoxyParamCaption})}

Take a slice of a vector until its end 
\begin{DoxyParams}{Parameters}
{\em v} & \\
\hline
{\em start} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_vectors_8h_ae11572812e4ad802473804201cc473f1}\label{_vectors_8h_ae11572812e4ad802473804201cc473f1}} 
\index{Vectors.h@{Vectors.h}!slice@{slice}}
\index{slice@{slice}!Vectors.h@{Vectors.h}}
\doxysubsubsection{\texorpdfstring{slice()}{slice()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::vector$<$T$>$ slice (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{const size\+\_\+t}]{start,  }\item[{const int}]{len }\end{DoxyParamCaption})}

Take a slice of a vector v starting at start of length len 
\begin{DoxyParams}{Parameters}
{\em v} & \\
\hline
{\em start} & \\
\hline
{\em len} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
