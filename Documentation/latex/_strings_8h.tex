\hypertarget{_strings_8h}{}\doxysection{src/\+Strings.h File Reference}
\label{_strings_8h}\index{src/Strings.h@{src/Strings.h}}
{\ttfamily \#include $<$sstream$>$}\newline
{\ttfamily \#include $<$queue$>$}\newline
{\ttfamily \#include $<$array$>$}\newline
{\ttfamily \#include $<$map$>$}\newline
{\ttfamily \#include $<$set$>$}\newline
{\ttfamily \#include $<$string.\+h$>$}\newline
{\ttfamily \#include \char`\"{}Numerics.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Random.\+h\char`\"{}}\newline
{\ttfamily \#include \char`\"{}Vector3\+D.\+h\char`\"{}}\newline
Include dependency graph for Strings.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_strings_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_strings_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structis__specialization}{is\+\_\+specialization$<$ Test, Ref $>$}}
\item 
struct \mbox{\hyperlink{structis__specialization_3_01_ref_3_01_args_8_8_8_01_4_00_01_ref_01_4}{is\+\_\+specialization$<$ Ref$<$ Args... $>$, Ref $>$}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_a4bc77a6f47e3046cc934b49f5e03a56f}{str}} (T x)
\item 
std\+::string \mbox{\hyperlink{_strings_8h_a21b313a5a03eda533ac68a4501c68c17}{str}} (const std\+::string \&x)
\item 
{\footnotesize template$<$typename... T, size\+\_\+t... I$>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_a9ab3d622399a5cd1e9fbaf8f38d8d394}{str}} (const std\+::tuple$<$ T... $>$ \&x, std\+::index\+\_\+sequence$<$ I... $>$ idx)
\item 
{\footnotesize template$<$typename... T$>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_af4fcc184e9e474c84204591dd7c95f1c}{str}} (const std\+::tuple$<$ T... $>$ \&x)
\item 
{\footnotesize template$<$typename T , size\+\_\+t N$>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_a66fc50785d7283d32f7f2e039e31b982}{str}} (const std\+::array$<$ T, N $>$ \&a)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_ac841190187b17808b2c4a82ecde6a140}{str}} (const std\+::vector$<$ T $>$ \&a)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string \mbox{\hyperlink{_strings_8h_a74a3109333f6ec7fc237e492a524da6a}{to\+\_\+string\+\_\+with\+\_\+precision}} (const T a\+\_\+value, const int n=14)
\item 
{\footnotesize template$<$typename T $>$ }\\bool \mbox{\hyperlink{_strings_8h_ac63ed4e974b8dc3b49eae65049ad7804}{is\+\_\+prefix}} (const T \&prefix, const T \&x)
\item 
bool \mbox{\hyperlink{_strings_8h_a9e236149ce0f5aa64d809fcca5cf1c27}{contains}} (const std\+::string \&s, const std\+::string \&x)
\item 
bool \mbox{\hyperlink{_strings_8h_a6424a030ce8c78fc72f206b0f92640e6}{contains}} (const std\+::string \&s, const char x)
\item 
{\footnotesize template$<$const float \& add\+\_\+p, const float \& del\+\_\+p$>$ }\\double \mbox{\hyperlink{_strings_8h_a006f42339c42d12497ad559987a8597c}{p\+\_\+delete\+\_\+append}} (const std\+::string \&x, const std\+::string \&y, const float log\+\_\+alphabet)
\begin{DoxyCompactList}\small\item\em Probability of converting x into y by deleting some number (each with del\+\_\+p, then stopping with prob 1-\/del\+\_\+p), adding with probability add\+\_\+p, and then when we add selecting from an alphabet of size alpha\+\_\+n. \end{DoxyCompactList}\item 
std\+::deque$<$ std\+::string $>$ \mbox{\hyperlink{_strings_8h_a60d3a9b47a988443407a595730086318}{split}} (const std\+::string \&s, const char delimiter)
\begin{DoxyCompactList}\small\item\em Split is returns a deque of s split up at the character delimiter. It handles these special cases\+: split(\char`\"{}a\+:\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}a\char`\"{}, \char`\"{}\char`\"{}\mbox{]} split(\char`\"{}\+:\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}\char`\"{}\mbox{]} split(\char`\"{}\+:a\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}\char`\"{}, \char`\"{}a\char`\"{}\mbox{]}. \end{DoxyCompactList}\item 
std\+::pair$<$ std\+::string, std\+::string $>$ \mbox{\hyperlink{_strings_8h_af8ae1cb99a3ece3691d6673b40b9d621}{divide}} (const std\+::string \&s, const char delimiter)
\item 
unsigned int \mbox{\hyperlink{_strings_8h_a51fc480ff96576142fbe0c1a5fc9114b}{levenshtein\+\_\+distance}} (const std\+::string \&s1, const std\+::string \&s2)
\item 
size\+\_\+t \mbox{\hyperlink{_strings_8h_ae6eafa3700b097b96c1601a141a45de4}{count}} (const std\+::string \&\mbox{\hyperlink{_strings_8h_ac841190187b17808b2c4a82ecde6a140}{str}}, const std\+::string \&sub)
\item 
std\+::string \mbox{\hyperlink{_strings_8h_a95521755321516e684a5bf762eb001d7}{reverse}} (std\+::string x)
\item 
std\+::string \mbox{\hyperlink{_strings_8h_a7058817dff18bae565e0f06bb9492bc4}{QQ}} (std\+::string x)
\item 
std\+::string \mbox{\hyperlink{_strings_8h_a1bb5ec0bee0c8456e3fcc87cc012d055}{Q}} (std\+::string x)
\item 
double \mbox{\hyperlink{_strings_8h_ac4b9409cdfb6a213710a66f0c02d5792}{p\+\_\+\+Kashyap\+Oommen1984\+\_\+edit}} (const std\+::string x, const std\+::string y, const double perr, const size\+\_\+t nalphabet)
\begin{DoxyCompactList}\small\item\em The string probability model from Kashyap \& Oommen, 1983, basically giving a string edit distance that is a probability model. This could really use some unit tests, but it is hard to find implementations. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{_strings_8h_aa8cda3705f8674293669932185337ebb}{string\+\_\+to}} (const std\+::string s)
\begin{DoxyCompactList}\small\item\em Fleet includes this templated function to allow us to convert strings to a variety of formats. This is mostly used for reading data from text files. This recursively will unpack containers with some standard delimiters. Since it can handle Fleet types (e.\+g. defaultdata\+\_\+t) it can be used to unpack data stored in strings (see e.\+g. Models/\+Sorting) \end{DoxyCompactList}\item 
template$<$$>$ std\+::string \mbox{\hyperlink{_strings_8h_ad1dfc3165dc24230d4269628a84ff58f}{string\+\_\+to}} (const std\+::string s)
\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const std\+::string \mbox{\hyperlink{_strings_8h_aefd49a74af3b4afc27512f639bcc336f}{E\+M\+P\+T\+Y\+\_\+\+S\+T\+R\+I\+NG}} = \char`\"{}\char`\"{}
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_strings_8h_a6424a030ce8c78fc72f206b0f92640e6}\label{_strings_8h_a6424a030ce8c78fc72f206b0f92640e6}} 
\index{Strings.h@{Strings.h}!contains@{contains}}
\index{contains@{contains}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool contains (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s,  }\item[{const char}]{x }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_a9e236149ce0f5aa64d809fcca5cf1c27}\label{_strings_8h_a9e236149ce0f5aa64d809fcca5cf1c27}} 
\index{Strings.h@{Strings.h}!contains@{contains}}
\index{contains@{contains}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{contains()}{contains()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool contains (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s,  }\item[{const std\+::string \&}]{x }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_ae6eafa3700b097b96c1601a141a45de4}\label{_strings_8h_ae6eafa3700b097b96c1601a141a45de4}} 
\index{Strings.h@{Strings.h}!count@{count}}
\index{count@{count}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{count()}{count()}}
{\footnotesize\ttfamily size\+\_\+t count (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{str,  }\item[{const std\+::string \&}]{sub }\end{DoxyParamCaption})}

How many times does sub occur in str? Does not count overlapping substrings 
\begin{DoxyParams}{Parameters}
{\em str} & \\
\hline
{\em sub} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_af8ae1cb99a3ece3691d6673b40b9d621}\label{_strings_8h_af8ae1cb99a3ece3691d6673b40b9d621}} 
\index{Strings.h@{Strings.h}!divide@{divide}}
\index{divide@{divide}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{divide()}{divide()}}
{\footnotesize\ttfamily std\+::pair$<$std\+::string, std\+::string$>$ divide (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s,  }\item[{const char}]{delimiter }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_ac63ed4e974b8dc3b49eae65049ad7804}\label{_strings_8h_ac63ed4e974b8dc3b49eae65049ad7804}} 
\index{Strings.h@{Strings.h}!is\_prefix@{is\_prefix}}
\index{is\_prefix@{is\_prefix}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{is\_prefix()}{is\_prefix()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
bool is\+\_\+prefix (\begin{DoxyParamCaption}\item[{const T \&}]{prefix,  }\item[{const T \&}]{x }\end{DoxyParamCaption})}

For any number of iterable types, is prefix a prefix of x 
\begin{DoxyParams}{Parameters}
{\em prefix} & \\
\hline
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a51fc480ff96576142fbe0c1a5fc9114b}\label{_strings_8h_a51fc480ff96576142fbe0c1a5fc9114b}} 
\index{Strings.h@{Strings.h}!levenshtein\_distance@{levenshtein\_distance}}
\index{levenshtein\_distance@{levenshtein\_distance}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{levenshtein\_distance()}{levenshtein\_distance()}}
{\footnotesize\ttfamily unsigned int levenshtein\+\_\+distance (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s1,  }\item[{const std\+::string \&}]{s2 }\end{DoxyParamCaption})}

Compute levenshtein distiance between two strings (N\+O\+TE\+: Or O(\+N$^\wedge$2)) 
\begin{DoxyParams}{Parameters}
{\em s1} & \\
\hline
{\em s2} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a006f42339c42d12497ad559987a8597c}\label{_strings_8h_a006f42339c42d12497ad559987a8597c}} 
\index{Strings.h@{Strings.h}!p\_delete\_append@{p\_delete\_append}}
\index{p\_delete\_append@{p\_delete\_append}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{p\_delete\_append()}{p\_delete\_append()}}
{\footnotesize\ttfamily template$<$const float \& add\+\_\+p, const float \& del\+\_\+p$>$ \\
double p\+\_\+delete\+\_\+append (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{x,  }\item[{const std\+::string \&}]{y,  }\item[{const float}]{log\+\_\+alphabet }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Probability of converting x into y by deleting some number (each with del\+\_\+p, then stopping with prob 1-\/del\+\_\+p), adding with probability add\+\_\+p, and then when we add selecting from an alphabet of size alpha\+\_\+n. 


\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
{\em del\+\_\+p} & -\/ probability of deleting the next character (geometric) \\
\hline
{\em add\+\_\+p} & -\/ probability of adding (geometric) \\
\hline
{\em alpha\+\_\+n} & -\/ size of alphabet \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The probability of converting x to y by deleting characters with probability del\+\_\+p and then adding with probability add\+\_\+p 
\end{DoxyReturn}
This function computes the probability that x would be converted into y, when we insert with probability add\+\_\+p and delete with probabiltiy del\+\_\+p and when we add we add from an alphabet of size log\+\_\+alphabet. Note that this is a template function because otherwise we end up computing log(add\+\_\+p) and log(del\+\_\+p) a lot, and these are in fact constant. 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
{\em log\+\_\+alphabet} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_ac4b9409cdfb6a213710a66f0c02d5792}\label{_strings_8h_ac4b9409cdfb6a213710a66f0c02d5792}} 
\index{Strings.h@{Strings.h}!p\_KashyapOommen1984\_edit@{p\_KashyapOommen1984\_edit}}
\index{p\_KashyapOommen1984\_edit@{p\_KashyapOommen1984\_edit}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{p\_KashyapOommen1984\_edit()}{p\_KashyapOommen1984\_edit()}}
{\footnotesize\ttfamily double p\+\_\+\+Kashyap\+Oommen1984\+\_\+edit (\begin{DoxyParamCaption}\item[{const std\+::string}]{x,  }\item[{const std\+::string}]{y,  }\item[{const double}]{perr,  }\item[{const size\+\_\+t}]{nalphabet }\end{DoxyParamCaption})}



The string probability model from Kashyap \& Oommen, 1983, basically giving a string edit distance that is a probability model. This could really use some unit tests, but it is hard to find implementations. 

This assumes that the deletions, insertions, and changes all happen with a constant, equal probability of perr, but note that swaps and insertions also have to choose the character out of nalphabet. This could probably be optimized to not have to compute these logs 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
{\em y} & \\
\hline
{\em perr} & \\
\hline
{\em nalphabet} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a1bb5ec0bee0c8456e3fcc87cc012d055}\label{_strings_8h_a1bb5ec0bee0c8456e3fcc87cc012d055}} 
\index{Strings.h@{Strings.h}!Q@{Q}}
\index{Q@{Q}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{Q()}{Q()}}
{\footnotesize\ttfamily std\+::string Q (\begin{DoxyParamCaption}\item[{std\+::string}]{x }\end{DoxyParamCaption})}

Handy adding single quotes to a string 
\begin{DoxyParams}{Parameters}
{\em x} & -\/ input string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a7058817dff18bae565e0f06bb9492bc4}\label{_strings_8h_a7058817dff18bae565e0f06bb9492bc4}} 
\index{Strings.h@{Strings.h}!QQ@{QQ}}
\index{QQ@{QQ}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{QQ()}{QQ()}}
{\footnotesize\ttfamily std\+::string QQ (\begin{DoxyParamCaption}\item[{std\+::string}]{x }\end{DoxyParamCaption})}

Handy adding double quotes to a string 
\begin{DoxyParams}{Parameters}
{\em x} & -\/ input string \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a95521755321516e684a5bf762eb001d7}\label{_strings_8h_a95521755321516e684a5bf762eb001d7}} 
\index{Strings.h@{Strings.h}!reverse@{reverse}}
\index{reverse@{reverse}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{reverse()}{reverse()}}
{\footnotesize\ttfamily std\+::string reverse (\begin{DoxyParamCaption}\item[{std\+::string}]{x }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_a60d3a9b47a988443407a595730086318}\label{_strings_8h_a60d3a9b47a988443407a595730086318}} 
\index{Strings.h@{Strings.h}!split@{split}}
\index{split@{split}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{split()}{split()}}
{\footnotesize\ttfamily std\+::deque$<$std\+::string$>$ split (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{s,  }\item[{const char}]{delimiter }\end{DoxyParamCaption})}



Split is returns a deque of s split up at the character delimiter. It handles these special cases\+: split(\char`\"{}a\+:\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}a\char`\"{}, \char`\"{}\char`\"{}\mbox{]} split(\char`\"{}\+:\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}\char`\"{}\mbox{]} split(\char`\"{}\+:a\char`\"{}, \textquotesingle{}\+:\textquotesingle{}) -\/$>$ \mbox{[}\char`\"{}\char`\"{}, \char`\"{}a\char`\"{}\mbox{]}. 

Split iwith a fixed return size, useful in parsing csv.


\begin{DoxyParams}{Parameters}
{\em s} & \\
\hline
{\em delimiter} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a66fc50785d7283d32f7f2e039e31b982}\label{_strings_8h_a66fc50785d7283d32f7f2e039e31b982}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename T , size\+\_\+t N$>$ \\
std\+::string str (\begin{DoxyParamCaption}\item[{const std\+::array$<$ T, N $>$ \&}]{a }\end{DoxyParamCaption})}

A pythonesque string function 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a21b313a5a03eda533ac68a4501c68c17}\label{_strings_8h_a21b313a5a03eda533ac68a4501c68c17}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily std\+::string str (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{x }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_af4fcc184e9e474c84204591dd7c95f1c}\label{_strings_8h_af4fcc184e9e474c84204591dd7c95f1c}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename... T$>$ \\
std\+::string str (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ T... $>$ \&}]{x }\end{DoxyParamCaption})}

A pythonesque string function 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a9ab3d622399a5cd1e9fbaf8f38d8d394}\label{_strings_8h_a9ab3d622399a5cd1e9fbaf8f38d8d394}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename... T, size\+\_\+t... I$>$ \\
std\+::string str (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ T... $>$ \&}]{x,  }\item[{std\+::index\+\_\+sequence$<$ I... $>$}]{idx }\end{DoxyParamCaption})}

A pythonesque string function 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_ac841190187b17808b2c4a82ecde6a140}\label{_strings_8h_ac841190187b17808b2c4a82ecde6a140}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string str (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{a }\end{DoxyParamCaption})}

A pythonesque string function 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_a4bc77a6f47e3046cc934b49f5e03a56f}\label{_strings_8h_a4bc77a6f47e3046cc934b49f5e03a56f}} 
\index{Strings.h@{Strings.h}!str@{str}}
\index{str@{str}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{str()}{str()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string str (\begin{DoxyParamCaption}\item[{T}]{x }\end{DoxyParamCaption})}

A pythonesque string function 
\begin{DoxyParams}{Parameters}
{\em x} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_aa8cda3705f8674293669932185337ebb}\label{_strings_8h_aa8cda3705f8674293669932185337ebb}} 
\index{Strings.h@{Strings.h}!string\_to@{string\_to}}
\index{string\_to@{string\_to}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{string\_to()}{string\_to()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
T string\+\_\+to (\begin{DoxyParamCaption}\item[{const std\+::string}]{s }\end{DoxyParamCaption})}



Fleet includes this templated function to allow us to convert strings to a variety of formats. This is mostly used for reading data from text files. This recursively will unpack containers with some standard delimiters. Since it can handle Fleet types (e.\+g. defaultdata\+\_\+t) it can be used to unpack data stored in strings (see e.\+g. Models/\+Sorting) 


\begin{DoxyParams}{Parameters}
{\em s} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}

\end{DoxyReturn}
\mbox{\Hypertarget{_strings_8h_ad1dfc3165dc24230d4269628a84ff58f}\label{_strings_8h_ad1dfc3165dc24230d4269628a84ff58f}} 
\index{Strings.h@{Strings.h}!string\_to@{string\_to}}
\index{string\_to@{string\_to}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{string\_to()}{string\_to()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$$>$ \\
float string\+\_\+to (\begin{DoxyParamCaption}\item[{const std\+::string}]{s }\end{DoxyParamCaption})}

\mbox{\Hypertarget{_strings_8h_a74a3109333f6ec7fc237e492a524da6a}\label{_strings_8h_a74a3109333f6ec7fc237e492a524da6a}} 
\index{Strings.h@{Strings.h}!to\_string\_with\_precision@{to\_string\_with\_precision}}
\index{to\_string\_with\_precision@{to\_string\_with\_precision}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{to\_string\_with\_precision()}{to\_string\_with\_precision()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
std\+::string to\+\_\+string\+\_\+with\+\_\+precision (\begin{DoxyParamCaption}\item[{const T}]{a\+\_\+value,  }\item[{const int}]{n = {\ttfamily 14} }\end{DoxyParamCaption})}



\doxysubsection{Variable Documentation}
\mbox{\Hypertarget{_strings_8h_aefd49a74af3b4afc27512f639bcc336f}\label{_strings_8h_aefd49a74af3b4afc27512f639bcc336f}} 
\index{Strings.h@{Strings.h}!EMPTY\_STRING@{EMPTY\_STRING}}
\index{EMPTY\_STRING@{EMPTY\_STRING}!Strings.h@{Strings.h}}
\doxysubsubsection{\texorpdfstring{EMPTY\_STRING}{EMPTY\_STRING}}
{\footnotesize\ttfamily const std\+::string E\+M\+P\+T\+Y\+\_\+\+S\+T\+R\+I\+NG = \char`\"{}\char`\"{}}

