\doxysection{File List}
Here is a list of all files with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{src/\mbox{\hyperlink{_base_node_8h}{Base\+Node.\+h}} \\*This is a general tree class, which we are adding because there are currently at least 3 different tree classes used in different parts of fleet (Nodes, M\+C\+TS, data for Binding\+Theory, etc.). This is an attempt to make a big superclass that puts all of this functionality in one place. It attempts to keep the node size small so that we can use this efficiently in M\+C\+TS in particular }{\pageref{_base_node_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_combinators_8h}{Combinators.\+h}} \\*A grammar for SK combinatory logic. N\+O\+TE\+: Custom\+Ops must be defined here }{\pageref{_combinators_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_eigen_lib_8h}{Eigen\+Lib.\+h}} }{\pageref{_eigen_lib_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_errors_8h}{Errors.\+h}} }{\pageref{_errors_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_fleet_8h}{Fleet.\+h}} \\*A fleet object manages processing the command line, prints a useful summary of command lines, and then on its destruction (or calling completed(), it prints out a summary of the total number of samples etc. run per second. This provides a shallow wrapper to C\+L\+I\+::\+App, meaning you add options to it just like C\+L\+I\+::\+App }{\pageref{_fleet_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_fleet_args_8h}{Fleet\+Args.\+h}} }{\pageref{_fleet_args_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_hash_8h}{Hash.\+h}} }{\pageref{_hash_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_i_o_8h}{I\+O.\+h}} }{\pageref{_i_o_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_miscellaneous_8h}{Miscellaneous.\+h}} }{\pageref{_miscellaneous_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_numerics_8h}{Numerics.\+h}} }{\pageref{_numerics_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_object_8h}{Object.\+h}} }{\pageref{_object_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_random_8h}{Random.\+h}} }{\pageref{_random_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_spin_lock_8h}{Spin\+Lock.\+h}} }{\pageref{_spin_lock_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_stack_8h}{Stack.\+h}} }{\pageref{_stack_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_strings_8h}{Strings.\+h}} }{\pageref{_strings_8h}}{}
\item\contentsline{section}{src/\mbox{\hyperlink{_timing_8h}{Timing.\+h}} }{\pageref{_timing_8h}}{}
\item\contentsline{section}{src/\+Containers/\mbox{\hyperlink{_discrete_distribution_8h}{Discrete\+Distribution.\+h}} \\*This stores a distribution from values of T to log probabilities. It is used as the return value from calls with randomness }{\pageref{_discrete_distribution_8h}}{}
\item\contentsline{section}{src/\+Containers/\mbox{\hyperlink{_top_8h}{Top.\+h}} \\*Check if a type has a posterior function or not }{\pageref{_top_8h}}{}
\item\contentsline{section}{src/\+Containers/\mbox{\hyperlink{_vector2_d_8h}{Vector2\+D.\+h}} }{\pageref{_vector2_d_8h}}{}
\item\contentsline{section}{src/\+Data/\mbox{\hyperlink{_datum_8h}{Datum.\+h}} \\*A datum is the default data point for likelihoods, consisting of an input and output type. The reliability is measures the reliability of the data (sometimes number of effective data points, sometimes its the noise in the likelihood }{\pageref{_datum_8h}}{}
\item\contentsline{section}{src/\+Data/\mbox{\hyperlink{_human_datum_8h}{Human\+Datum.\+h}} }{\pageref{_human_datum_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_enumeration_8h}{Enumeration.\+h}} \\*An \mbox{\hyperlink{class_integerized_stack}{Integerized\+Stack}} is just a wrapper around unsigned longs that allow them to behave like a of integers stack, supporting push and pop (maybe with mod) via a standard pairing function }{\pageref{_enumeration_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_grammar_8h}{Grammar.\+h}} \\*This is a little magic used to check the ordering of P\+R\+I\+M\+I\+T\+I\+V\+ES to ensure that we never have a \mbox{\hyperlink{struct_primitive}{Primitive}} {\itshape after} a \mbox{\hyperlink{struct_builtin_primitive}{Builtin\+Primitive}}, since if we do that messes up how we call in apply\+Primitives }{\pageref{_grammar_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_integerized_stack_8h}{Integerized\+Stack.\+h}} }{\pageref{_integerized_stack_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_node_8h}{Node.\+h}} }{\pageref{_node_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_nonterminal_8h}{Nonterminal.\+h}} }{\pageref{_nonterminal_8h}}{}
\item\contentsline{section}{src/\+Grammar/\mbox{\hyperlink{_rule_8h}{Rule.\+h}} \\*A \mbox{\hyperlink{class_rule}{Rule}} stores one possible expansion in the grammar, specifying a nonterminal type, an instruction that gets executed, a forma string, a number of children, and an array of types of each child. Here we \char`\"{}emulate\char`\"{} a type system using t\+\_\+nonterminal to store an integer for the types. $\ast$ }{\pageref{_rule_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\mbox{\hyperlink{_grammar_hypothesis_8h}{Grammar\+Hypothesis.\+h}} \\*This stores the human data, as a list of data to condition on data\mbox{[}0\+:ndata\mbox{]}, the data you predict on, and then correct/total counts We defaultly use the H\+YP\textquotesingle{}s output, datum, and data types, but this allows us to specify something different if that\textquotesingle{}s more convenient }{\pageref{_grammar_hypothesis_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\mbox{\hyperlink{_lexicon_8h}{Lexicon.\+h}} \\*A lexicon stores an association of numbers (in a vector) to some other kind of hypotheses (typically a \mbox{\hyperlink{class_l_o_t_hypothesis}{L\+O\+T\+Hypothesis}}). Each of these components is called a \char`\"{}factor.\char`\"{} }{\pageref{_lexicon_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\mbox{\hyperlink{_l_o_t_hypothesis_8h}{L\+O\+T\+Hypothesis.\+h}} \\*A \mbox{\hyperlink{class_l_o_t_hypothesis}{L\+O\+T\+Hypothesis}} is the basic unit for doing L\+OT models. It is templated with itself (the curiously recurring tempalte pattern), an input type, and output type, a grammar type, and types for the individual data elements and vector of data. Usually you will subclass this (or a \mbox{\hyperlink{class_lexicon}{Lexicon}}) as this\+\_\+totheses in a L\+OT model }{\pageref{_l_o_t_hypothesis_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\mbox{\hyperlink{_proposers_8h}{Proposers.\+h}} }{\pageref{_proposers_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\mbox{\hyperlink{_vector_hypothesis_8h}{Vector\+Hypothesis.\+h}} \\*This has all of the \mbox{\hyperlink{class_m_c_m_cable}{M\+C\+M\+Cable}} interfaces but jsut represents n unit Gaussians. This is primarily used in Grammar\+Inference to represent parameters, but it could be used in any other too }{\pageref{_vector_hypothesis_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\mbox{\hyperlink{_bayesable_8h}{Bayesable.\+h}} \\*The \mbox{\hyperlink{class_bayesable}{Bayesable}} class provides an interface for hypotheses that support Bayesian inference (e.\+g. computing priors, likelihoods, and posteriors) Note that this class stores prior, likelihood, posterior always at temperature 1.\+0, and you can get the values of the posterior at other temperatures via \mbox{\hyperlink{class_bayesable_acf805473a9eea0df96d6267dca0e9c87}{Bayesable.\+at\+\_\+temperature(double t)}} }{\pageref{_bayesable_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\mbox{\hyperlink{_m_c_m_cable_8h}{M\+C\+M\+Cable.\+h}} \\*A class is \mbox{\hyperlink{class_m_c_m_cable}{M\+C\+M\+Cable}} if it is \mbox{\hyperlink{class_bayesable}{Bayesable}} and lets us propose, restart, and check equality (which M\+C\+MC does for speed) }{\pageref{_m_c_m_cable_8h}}{}
\item\contentsline{section}{src/\+Hypotheses/\+Interfaces/\mbox{\hyperlink{_searchable_8h}{Searchable.\+h}} \\*A class is searchable if permits us to enumerate and make its neighbors. This class is used by M\+C\+TS and allows us to incrementally search a hypothesis }{\pageref{_searchable_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_beam_search_8h}{Beam\+Search.\+h}} \\*This is an implementation of beam search that maintains a priority queue of partial states and attempts to find a program with the lowest posterior score. To do this, we choose a node to expand based on its prior plus N\+\_\+\+R\+E\+PS samples of its likelihood, computed by filling in its children at random. This stochastic heuristic is actually inadmissable (in A$\ast$ terms) since it usually overestimates the cost. As a result, it usually makes sense to run at a pretty high temperature, corresponding to a downweighting of the likelihood, and making the heuristic more likely to be admissable }{\pageref{_beam_search_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_chain_pool_8h}{Chain\+Pool.\+h}} \\*A \mbox{\hyperlink{class_chain_pool}{Chain\+Pool}} stores a bunch of M\+C\+M\+C\+Chains and allows you to run them serially or in parallel. N\+O\+TE\+: When you use a \mbox{\hyperlink{class_chain_pool}{Chain\+Pool}}, the results will not be reproducible with seed because timing determines when you switch chains }{\pageref{_chain_pool_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_control_8h}{Control.\+h}} \\*This class has all the information for running M\+C\+MC or M\+C\+TS in a little package. It defaultly constructs (via \mbox{\hyperlink{struct_control}{Control()}}) to read these from \mbox{\hyperlink{namespace_fleet_args}{Fleet\+Args}}, which are a bunch of variables set by Fleet\+::initialize from the command line. This makes it especially convenient to call with command line arguments, but others can be specified as well }{\pageref{_control_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_enumeration_inference_8h}{Enumeration\+Inference.\+h}} \\*Enumeration inferences enumerates hypotheses using a counting algorithm from the grammar. It supports multithreading and requires a hypothesis, grammar, start type, and callback }{\pageref{_enumeration_inference_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_m_c_m_c_chain_8h}{M\+C\+M\+C\+Chain.\+h}} }{\pageref{_m_c_m_c_chain_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_m_c_t_s_8h}{M\+C\+T\+S.\+h}} \\*This is a version of M\+C\+TS that plays out children nplayouts times instead of expanding a full tree }{\pageref{_m_c_t_s_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_parallel_inference_interface_8h}{Parallel\+Inference\+Interface.\+h}} }{\pageref{_parallel_inference_interface_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_parallel_tempering_8h}{Parallel\+Tempering.\+h}} \\*This is a chain pool that runs multiple chains on a ladder of different temperatures and adjusts temperatures in order to balances swaps up and down the ladder (which makes it efficient). The adaptation scheme follows \href{https://arxiv.org/abs/1501.05823}{\texttt{ https\+://arxiv.\+org/abs/1501.\+05823}} N\+O\+TE This starts two extra threads, one for adapting and one for swapping, but they mostly wait around }{\pageref{_parallel_tempering_8h}}{}
\item\contentsline{section}{src/\+Inference/\mbox{\hyperlink{_prior_inference_8h}{Prior\+Inference.\+h}} \\*Inference by sampling from the prior -- doesn\textquotesingle{}t tend to work well, but might be a useful baseline }{\pageref{_prior_inference_8h}}{}
\item\contentsline{section}{src/\+Statistics/\mbox{\hyperlink{_finite_history_8h}{Finite\+History.\+h}} \\*A \mbox{\hyperlink{class_finite_history}{Finite\+History}} stores the previous N examples of something of type T. This is used e.\+g. in M\+C\+MC in order to count the acceptance ratio on the previous N samples }{\pageref{_finite_history_8h}}{}
\item\contentsline{section}{src/\+Statistics/\mbox{\hyperlink{_fleet_statistics_8h}{Fleet\+Statistics.\+h}} }{\pageref{_fleet_statistics_8h}}{}
\item\contentsline{section}{src/\+Statistics/\mbox{\hyperlink{_median_f_a_m_e_8h}{Median\+F\+A\+M\+E.\+h}} \\*A streaming median class implementing the F\+A\+ME algorithm Here, we initialize both the step size and M with the current sample \href{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.108.7376&rep=rep1&type=pdf}{\texttt{ http\+://citeseerx.\+ist.\+psu.\+edu/viewdoc/download?doi=10.\+1.\+1.\+108.\+7376\&rep=rep1\&type=pdf}} }{\pageref{_median_f_a_m_e_8h}}{}
\item\contentsline{section}{src/\+Statistics/\mbox{\hyperlink{_reservoir_sample_8h}{Reservoir\+Sample.\+h}} \\*A reservoir sampling algorithm. N\+O\+TE\+: This was simplified from an old version that permitted unequal weights among elements. We may go back to that eventually -\/ \href{https://en.wikipedia.org/wiki/Reservoir_sampling\#Weighted_random_sampling_}{\texttt{ https\+://en.\+wikipedia.\+org/wiki/\+Reservoir\+\_\+sampling\#\+Weighted\+\_\+random\+\_\+sampling\+\_\+}} }{\pageref{_reservoir_sample_8h}}{}
\item\contentsline{section}{src/\+Statistics/\mbox{\hyperlink{_streaming_statistics_8h}{Streaming\+Statistics.\+h}} \\*A class to store a bunch of statistics about incoming data points, including min, max, mean, etc. This also stores a reservoir sample and allow us to compute how often one distribution exceeds another }{\pageref{_streaming_statistics_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{apply_primitives_8h}{apply\+Primitives.\+h}} }{\pageref{apply_primitives_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_builtins_8h}{Builtins.\+h}} \\*This is needed below so we can check if something is a \mbox{\hyperlink{namespace_builtin}{Builtin}} without template args }{\pageref{_builtins_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_case_macros_8h}{Case\+Macros.\+h}} }{\pageref{_case_macros_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_instruction_8h}{Instruction.\+h}} \\*This is an error type that is returned if we get a runtime error (e.\+g. string length, etc.) }{\pageref{_instruction_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_primitives_8h}{Primitives.\+h}} \\*If there are any references in the arguments, only the first can be a reference }{\pageref{_primitives_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_program_8h}{Program.\+h}} }{\pageref{_program_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_virtual_machine_pool_8h}{Virtual\+Machine\+Pool.\+h}} \\*This manages a collection of Virtual\+Machines -- this is what handles the enumeration of flip by probability. Basically each machine state stores the state of some evaluator and is able to push things back on to the Q if it encounters a random flip This stores pointers because it is impossible to copy out of std collections, so we are constantly having to call \mbox{\hyperlink{class_virtual_machine_state}{Virtual\+Machine\+State}} constructors. Using pointers speeds us up by about 20\% }{\pageref{_virtual_machine_pool_8h}}{}
\item\contentsline{section}{src/\+Virtual\+Machine/\mbox{\hyperlink{_virtual_machine_state_8h}{Virtual\+Machine\+State.\+h}} \\*Count references in lambda arguments (used to ensure we only passs one) }{\pageref{_virtual_machine_state_8h}}{}
\item\contentsline{section}{Testing/\+Basics/\mbox{\hyperlink{_main_8cpp}{Main.\+cpp}} \\*This stores an ojbect with feature F\+A\+R\+GS which is meant to be something like enums. These are often used to store features that L\+OT expressions operate on, for instance the objects that boolean logic operates on }{\pageref{_main_8cpp}}{}
\end{DoxyCompactList}
