<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fleet: Grammar&lt; GRAMMAR_TYPES &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_sm.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fleet
   &#160;<span id="projectnumber">0.0.9</span>
   </div>
   <div id="projectbrief">Inference in the LOT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_grammar-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grammar&lt; GRAMMAR_TYPES &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_grammar_8h_source.html">Grammar.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a30c2eaa4b378738686365fc6d8697f61"><td class="memTemplParams" colspan="2">template&lt;typename input_t , typename output_t &gt; </td></tr>
<tr class="memitem:a30c2eaa4b378738686365fc6d8697f61"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a30c2eaa4b378738686365fc6d8697f61">VirtualMachineState_t</a> = <a class="el" href="class_virtual_machine_state.html">VirtualMachineState</a>&lt; input_t, output_t, GRAMMAR_TYPES... &gt;</td></tr>
<tr class="separator:a30c2eaa4b378738686365fc6d8697f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba44586d1c6f847cbbeeead91964e3c"><td class="memItemLeft" align="right" valign="top">typedef std::tuple&lt; GRAMMAR_TYPES... &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a5ba44586d1c6f847cbbeeead91964e3c">GrammarTypesAsTuple</a></td></tr>
<tr class="separator:a5ba44586d1c6f847cbbeeead91964e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a047b55bfbd87c52e9d969af62c2932ab"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a047b55bfbd87c52e9d969af62c2932ab"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a> ()</td></tr>
<tr class="separator:a047b55bfbd87c52e9d969af62c2932ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa1d41e021616790a5ec8f4b3de9b08"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a2fa1d41e021616790a5ec8f4b3de9b08">Grammar</a> ()</td></tr>
<tr class="separator:a2fa1d41e021616790a5ec8f4b3de9b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db6840d96e910a788968ebb2fe62df4"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:a7db6840d96e910a788968ebb2fe62df4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a7db6840d96e910a788968ebb2fe62df4">Grammar</a> (std::tuple&lt; T... &gt; tup)</td></tr>
<tr class="separator:a7db6840d96e910a788968ebb2fe62df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70df918794a43cbd26bae1096c92dead"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a70df918794a43cbd26bae1096c92dead">Grammar</a> (const <a class="el" href="class_grammar.html">Grammar</a> &amp;g)=delete</td></tr>
<tr class="separator:a70df918794a43cbd26bae1096c92dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b2bd47d150afe8ab304e6d213f0ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a008b2bd47d150afe8ab304e6d213f0ba">Grammar</a> (const <a class="el" href="class_grammar.html">Grammar</a> &amp;&amp;g)=delete</td></tr>
<tr class="separator:a008b2bd47d150afe8ab304e6d213f0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa05c747026932672a24fa1f7134115"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a4aa05c747026932672a24fa1f7134115">count_nonterminals</a> () const</td></tr>
<tr class="separator:a4aa05c747026932672a24fa1f7134115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a765c97b89f2f4cf12b6b4c2a3d019"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a90a765c97b89f2f4cf12b6b4c2a3d019">count_rules</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>) const</td></tr>
<tr class="separator:a90a765c97b89f2f4cf12b6b4c2a3d019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576605ca6ee9693b762a40c477aa4889"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a576605ca6ee9693b762a40c477aa4889">count_rules</a> () const</td></tr>
<tr class="separator:a576605ca6ee9693b762a40c477aa4889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5121201035b5d5cd0a1d4251b1f73056"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a5121201035b5d5cd0a1d4251b1f73056">count_terminals</a> (<a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>) const</td></tr>
<tr class="separator:a5121201035b5d5cd0a1d4251b1f73056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335c2679b0db2290a1a0da8910f0bcdd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a335c2679b0db2290a1a0da8910f0bcdd">count_nonterminals</a> (<a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>) const</td></tr>
<tr class="separator:a335c2679b0db2290a1a0da8910f0bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d661258f08b7cc4d154d59bfbbc1f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a8d661258f08b7cc4d154d59bfbbc1f68">show</a> (std::string prefix=&quot;# &quot;)</td></tr>
<tr class="memdesc:a8d661258f08b7cc4d154d59bfbbc1f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given nt, returns the number of finite trees that nt can expand to if its finite; 0 if its infinite. * <br  />
  <a href="class_grammar.html#a8d661258f08b7cc4d154d59bfbbc1f68">More...</a><br /></td></tr>
<tr class="separator:a8d661258f08b7cc4d154d59bfbbc1f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be4926e40ea476152a5a87a1c83f167"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a0be4926e40ea476152a5a87a1c83f167">add</a> (<a class="el" href="class_rule.html">Rule</a> &amp;&amp;r)</td></tr>
<tr class="separator:a0be4926e40ea476152a5a87a1c83f167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4f41d4b1ff3c9973cb13ccea2c57fb"><td class="memTemplParams" colspan="2">template&lt;typename... args, size_t... Is&gt; </td></tr>
<tr class="memitem:a3c4f41d4b1ff3c9973cb13ccea2c57fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a3c4f41d4b1ff3c9973cb13ccea2c57fb">add</a> (std::tuple&lt; args... &gt; t, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a3c4f41d4b1ff3c9973cb13ccea2c57fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86dfa9ce87af1779799e617bb3252220"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:a86dfa9ce87af1779799e617bb3252220"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a86dfa9ce87af1779799e617bb3252220">add</a> (<a class="el" href="struct_primitive.html">Primitive</a>&lt; T, args... &gt; p, const int arg=0)</td></tr>
<tr class="separator:a86dfa9ce87af1779799e617bb3252220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b751ef5987563d4045692199dba16c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:a52b751ef5987563d4045692199dba16c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a52b751ef5987563d4045692199dba16c">add</a> (<a class="el" href="struct_builtin_primitive.html">BuiltinPrimitive</a>&lt; T, args... &gt; p, const int arg=0)</td></tr>
<tr class="separator:a52b751ef5987563d4045692199dba16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3a7374f7aa01a1db5b938e8b9dfa2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... args&gt; </td></tr>
<tr class="memitem:ada3a7374f7aa01a1db5b938e8b9dfa2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#ada3a7374f7aa01a1db5b938e8b9dfa2d">add</a> (<a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a> o, std::string format, const double p=1.0, const int arg=0)</td></tr>
<tr class="separator:ada3a7374f7aa01a1db5b938e8b9dfa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16885c3de4a6e3fd31ddab136cd9fea8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a16885c3de4a6e3fd31ddab136cd9fea8">get_index_of</a> (const <a class="el" href="class_rule.html">Rule</a> *r) const</td></tr>
<tr class="separator:a16885c3de4a6e3fd31ddab136cd9fea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed04fb2a2a8e2f0e4f11b711647a02c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a9ed04fb2a2a8e2f0e4f11b711647a02c">get_rule</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>, size_t k) const</td></tr>
<tr class="separator:a9ed04fb2a2a8e2f0e4f11b711647a02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57835af24b91d1c193f2906b43282350"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a57835af24b91d1c193f2906b43282350">get_rule</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>, const <a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a> o, const int a=0)</td></tr>
<tr class="separator:a57835af24b91d1c193f2906b43282350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d13aad0e640f20e9eb7d0d148915576"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a3d13aad0e640f20e9eb7d0d148915576">get_rule</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>, const std::string s) const</td></tr>
<tr class="separator:a3d13aad0e640f20e9eb7d0d148915576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a48e2e6b4757c3398c60a20d759d307"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a1a48e2e6b4757c3398c60a20d759d307">get_rule</a> (const std::string s) const</td></tr>
<tr class="separator:a1a48e2e6b4757c3398c60a20d759d307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240019987945a694e26bebcebcf463fc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a240019987945a694e26bebcebcf463fc">rule_normalizer</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>) const</td></tr>
<tr class="separator:a240019987945a694e26bebcebcf463fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4d092714b8420d8c0a1be63e8566b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_rule.html">Rule</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aba4d092714b8420d8c0a1be63e8566b6">sample_rule</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>) const</td></tr>
<tr class="separator:aba4d092714b8420d8c0a1be63e8566b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6f2a046bdf8df0be45912b5d8fe410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#abc6f2a046bdf8df0be45912b5d8fe410">makeNode</a> (const <a class="el" href="class_rule.html">Rule</a> *r) const</td></tr>
<tr class="separator:abc6f2a046bdf8df0be45912b5d8fe410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dee7ec88bdd66edd023b3c935d2765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af5dee7ec88bdd66edd023b3c935d2765">generate</a> (const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html#a047b55bfbd87c52e9d969af62c2932ab">nt</a>, unsigned long depth=0) const</td></tr>
<tr class="separator:af5dee7ec88bdd66edd023b3c935d2765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bf556e22bfdd5ec87868869fd9330f"><td class="memTemplParams" colspan="2">template&lt;class t &gt; </td></tr>
<tr class="memitem:a01bf556e22bfdd5ec87868869fd9330f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a01bf556e22bfdd5ec87868869fd9330f">generate</a> (unsigned long depth=0)</td></tr>
<tr class="separator:a01bf556e22bfdd5ec87868869fd9330f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b35de7e71ac8f451cd3a65818fc1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a28b35de7e71ac8f451cd3a65818fc1db">copy_resample</a> (const <a class="el" href="class_node.html">Node</a> &amp;node, bool f(const <a class="el" href="class_node.html">Node</a> &amp;n)) const</td></tr>
<tr class="separator:a28b35de7e71ac8f451cd3a65818fc1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e192e96e623cf9beb927cbd35bd7470"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a1e192e96e623cf9beb927cbd35bd7470">get_counts</a> (const <a class="el" href="class_node.html">Node</a> &amp;node) const</td></tr>
<tr class="separator:a1e192e96e623cf9beb927cbd35bd7470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b19c0b8d0b4d792181ae47bd2f68268"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a4b19c0b8d0b4d792181ae47bd2f68268">log_probability</a> (const <a class="el" href="class_node.html">Node</a> &amp;n) const</td></tr>
<tr class="separator:a4b19c0b8d0b4d792181ae47bd2f68268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef582b15696b97c3376cba935a76acef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#aef582b15696b97c3376cba935a76acef">expand_from_names</a> (std::deque&lt; std::string &gt; &amp;q) const</td></tr>
<tr class="separator:aef582b15696b97c3376cba935a76acef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a651b1fb2cad39efc4717b635b922e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a53a651b1fb2cad39efc4717b635b922e">expand_from_names</a> (std::string s) const</td></tr>
<tr class="separator:a53a651b1fb2cad39efc4717b635b922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8e4c2b0ad93970e579ea56c2fde60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_node.html">Node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#af4f8e4c2b0ad93970e579ea56c2fde60">expand_from_names</a> (const char *c) const</td></tr>
<tr class="separator:af4f8e4c2b0ad93970e579ea56c2fde60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486cec3b8e6c757eb348031ff8118a99"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a486cec3b8e6c757eb348031ff8118a99">neighbors</a> (const <a class="el" href="class_node.html">Node</a> &amp;node) const</td></tr>
<tr class="separator:a486cec3b8e6c757eb348031ff8118a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0765273e6b0957410447ad5d74e424bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a0765273e6b0957410447ad5d74e424bf">expand_to_neighbor</a> (<a class="el" href="class_node.html">Node</a> &amp;node, int &amp;which)</td></tr>
<tr class="separator:a0765273e6b0957410447ad5d74e424bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e6e5072b99611de47c4be3ab78761c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a36e6e5072b99611de47c4be3ab78761c">neighbor_prior</a> (const <a class="el" href="class_node.html">Node</a> &amp;node, int &amp;which) const</td></tr>
<tr class="separator:a36e6e5072b99611de47c4be3ab78761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a44e86d41c6e8a8ff7665208ac55da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a51a44e86d41c6e8a8ff7665208ac55da">complete</a> (<a class="el" href="class_node.html">Node</a> &amp;node)</td></tr>
<tr class="separator:a51a44e86d41c6e8a8ff7665208ac55da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9ec7418e0263e2ade2340e248c04275d"><td class="memTemplParams" colspan="2">template&lt;typename X &gt; </td></tr>
<tr class="memitem:a9ec7418e0263e2ade2340e248c04275d"><td class="memTemplItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_grammar.html#a9ec7418e0263e2ade2340e248c04275d">is_in_GRAMMAR_TYPES</a> ()</td></tr>
<tr class="separator:a9ec7418e0263e2ade2340e248c04275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8a89ced0753d72f52ccf2b04c0ccc82b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_rule.html">Rule</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a8a89ced0753d72f52ccf2b04c0ccc82b">rules</a> [<a class="el" href="class_grammar.html#a45877d4d7a5ee98bf6753af593d6ca08">N_NTs</a>]</td></tr>
<tr class="separator:a8a89ced0753d72f52ccf2b04c0ccc82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63420ee4232c46523a46bd881cb3e2f5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a63420ee4232c46523a46bd881cb3e2f5">Z</a> [<a class="el" href="class_grammar.html#a45877d4d7a5ee98bf6753af593d6ca08">N_NTs</a>]</td></tr>
<tr class="separator:a63420ee4232c46523a46bd881cb3e2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a45877d4d7a5ee98bf6753af593d6ca08"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a45877d4d7a5ee98bf6753af593d6ca08">N_NTs</a> = std::tuple_size&lt;std::tuple&lt;GRAMMAR_TYPES...&gt;&gt;::value</td></tr>
<tr class="separator:a45877d4d7a5ee98bf6753af593d6ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0d1d38426ce7f1b68c001e9ddec064"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_grammar.html#a4a0d1d38426ce7f1b68c001e9ddec064">GRAMMAR_MAX_DEPTH</a> = 64</td></tr>
<tr class="separator:a4a0d1d38426ce7f1b68c001e9ddec064"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5ba44586d1c6f847cbbeeead91964e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba44586d1c6f847cbbeeead91964e3c">&#9670;&nbsp;</a></span>GrammarTypesAsTuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;GRAMMAR_TYPES...&gt; <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html#a5ba44586d1c6f847cbbeeead91964e3c">GrammarTypesAsTuple</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30c2eaa4b378738686365fc6d8697f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c2eaa4b378738686365fc6d8697f61">&#9670;&nbsp;</a></span>VirtualMachineState_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename input_t , typename output_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html#a30c2eaa4b378738686365fc6d8697f61">VirtualMachineState_t</a> =  <a class="el" href="class_virtual_machine_state.html">VirtualMachineState</a>&lt;input_t, output_t, GRAMMAR_TYPES...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2fa1d41e021616790a5ec8f4b3de9b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa1d41e021616790a5ec8f4b3de9b08">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html">Grammar</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db6840d96e910a788968ebb2fe62df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db6840d96e910a788968ebb2fe62df4">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename... T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html">Grammar</a> </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; T... &gt;&#160;</td>
          <td class="paramname"><em>tup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor for grammar that uses a tuple of Primitives. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tup</td><td>- a tuple of Primitives</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70df918794a43cbd26bae1096c92dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70df918794a43cbd26bae1096c92dead">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html">Grammar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt; &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a008b2bd47d150afe8ab304e6d213f0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b2bd47d150afe8ab304e6d213f0ba">&#9670;&nbsp;</a></span>Grammar() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::<a class="el" href="class_grammar.html">Grammar</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada3a7374f7aa01a1db5b938e8b9dfa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3a7374f7aa01a1db5b938e8b9dfa2d">&#9670;&nbsp;</a></span>add() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>p</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a52b751ef5987563d4045692199dba16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b751ef5987563d4045692199dba16c">&#9670;&nbsp;</a></span>add() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_builtin_primitive.html">BuiltinPrimitive</a>&lt; T, args... &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86dfa9ce87af1779799e617bb3252220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86dfa9ce87af1779799e617bb3252220">&#9670;&nbsp;</a></span>add() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename T , typename... args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_primitive.html">Primitive</a>&lt; T, args... &gt;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>arg</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0be4926e40ea476152a5a87a1c83f167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be4926e40ea476152a5a87a1c83f167">&#9670;&nbsp;</a></span>add() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_rule.html">Rule</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a rule</p>

</div>
</div>
<a id="a3c4f41d4b1ff3c9973cb13ccea2c57fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4f41d4b1ff3c9973cb13ccea2c57fb">&#9670;&nbsp;</a></span>add() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename... args, size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::add </td>
          <td>(</td>
          <td class="paramtype">std::tuple&lt; args... &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51a44e86d41c6e8a8ff7665208ac55da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a44e86d41c6e8a8ff7665208ac55da">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28b35de7e71ac8f451cd3a65818fc1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b35de7e71ac8f451cd3a65818fc1db">&#9670;&nbsp;</a></span>copy_resample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::copy_resample </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>f</em>const Node &amp;n&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a copy of node where all nodes satisfying f are regenerated from the grammar. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
    <tr><td class="paramname">f</td><td>- a function saying what we should resample </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NOTE: this does NOT allow f to apply to nullptr children (so cannot be used to fill in)</dd></dl>

</div>
</div>
<a id="a4aa05c747026932672a24fa1f7134115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa05c747026932672a24fa1f7134115">&#9670;&nbsp;</a></span>count_nonterminals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::count_nonterminals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How many nonterminals are there in the grammar. </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a335c2679b0db2290a1a0da8910f0bcdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335c2679b0db2290a1a0da8910f0bcdd">&#9670;&nbsp;</a></span>count_nonterminals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::count_nonterminals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count th enumber of non-terminal rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a576605ca6ee9693b762a40c477aa4889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576605ca6ee9693b762a40c477aa4889">&#9670;&nbsp;</a></span>count_rules() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::count_rules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total number of rules </p><dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a90a765c97b89f2f4cf12b6b4c2a3d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a765c97b89f2f4cf12b6b4c2a3d019">&#9670;&nbsp;</a></span>count_rules() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::count_rules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a5121201035b5d5cd0a1d4251b1f73056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5121201035b5d5cd0a1d4251b1f73056">&#9670;&nbsp;</a></span>count_terminals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::count_terminals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Count the number of terminal rules of return type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af4f8e4c2b0ad93970e579ea56c2fde60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8e4c2b0ad93970e579ea56c2fde60">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef582b15696b97c3376cba935a76acef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef582b15696b97c3376cba935a76acef">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">std::deque&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills an entire tree using the string format prefixes &ndash; see get_rule(std::string). Here q should contain strings like "3:'a'" which says expand nonterminal type 3 to the rule matching 'a' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a53a651b1fb2cad39efc4717b635b922e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a651b1fb2cad39efc4717b635b922e">&#9670;&nbsp;</a></span>expand_from_names() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::expand_from_names </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Expand from names where s is delimited by ':' </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a0765273e6b0957410447ad5d74e424bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0765273e6b0957410447ad5d74e424bf">&#9670;&nbsp;</a></span>expand_to_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::expand_to_neighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af5dee7ec88bdd66edd023b3c935d2765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dee7ec88bdd66edd023b3c935d2765">&#9670;&nbsp;</a></span>generate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::generate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sample an entire tree from this grammar (keeping track of depth in case we recurse too far) of return type nt. This samples a rule, makes them with makeNode, and then recurses. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="class_node.html">Node</a> sampled from the grammar.</dd></dl>
<p>NOTE: this may throw a DepthException if the grammar recurses too far (usually that means the grammar is improper)</p>

</div>
</div>
<a id="a01bf556e22bfdd5ec87868869fd9330f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01bf556e22bfdd5ec87868869fd9330f">&#9670;&nbsp;</a></span>generate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;class t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::generate </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A friendly version of generate that can be called with template by type. <br  />
 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1e192e96e623cf9beb927cbd35bd7470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e192e96e623cf9beb927cbd35bd7470">&#9670;&nbsp;</a></span>get_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_counts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a vector of counts of how often each rule was used, in a <em>standard</em> order given by iterating over nts and then iterating over rules </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a16885c3de4a6e3fd31ddab136cd9fea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16885c3de4a6e3fd31ddab136cd9fea8">&#9670;&nbsp;</a></span>get_index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_index_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the index in rules of where r is. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a57835af24b91d1c193f2906b43282350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57835af24b91d1c193f2906b43282350">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_instruction_8h.html#af2fb7c87c5854c5733d7bb0506b06de7">BuiltinOp</a>&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get rule of type nt with a given BuiltinOp and argument a </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">o</td><td></td></tr>
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a3d13aad0e640f20e9eb7d0d148915576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d13aad0e640f20e9eb7d0d148915576">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a rule based on s, which must uniquely be a prefix of the rule's format of a given nonterminal type. If s is the empty string, however, it must match exactly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9ed04fb2a2a8e2f0e4f11b711647a02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed04fb2a2a8e2f0e4f11b711647a02c">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the k'th rule of type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
    <tr><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1a48e2e6b4757c3398c60a20d759d307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a48e2e6b4757c3398c60a20d759d307">&#9670;&nbsp;</a></span>get_rule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::get_rule </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a rule based on s, which must uniquely be a prefix of the rule's format. If s is the empty string, however, it must match exactly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9ec7418e0263e2ade2340e248c04275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ec7418e0263e2ade2340e248c04275d">&#9670;&nbsp;</a></span>is_in_GRAMMAR_TYPES()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;typename X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::is_in_GRAMMAR_TYPES </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b19c0b8d0b4d792181ae47bd2f68268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b19c0b8d0b4d792181ae47bd2f68268">&#9670;&nbsp;</a></span>log_probability()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::log_probability </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the log probability of a tree according to the grammar. NOTE: here we ignore nodes that are Null meaning that we compute the partial probability </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="abc6f2a046bdf8df0be45912b5d8fe410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6f2a046bdf8df0be45912b5d8fe410">&#9670;&nbsp;</a></span>makeNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_node.html">Node</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::makeNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_rule.html">Rule</a> *&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to create a node according to this grammar. This is how nodes get their log probabilities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a36e6e5072b99611de47c4be3ab78761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e6e5072b99611de47c4be3ab78761c">&#9670;&nbsp;</a></span>neighbor_prior()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::neighbor_prior </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>which</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a486cec3b8e6c757eb348031ff8118a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486cec3b8e6c757eb348031ff8118a99">&#9670;&nbsp;</a></span>neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a047b55bfbd87c52e9d969af62c2932ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047b55bfbd87c52e9d969af62c2932ab">&#9670;&nbsp;</a></span>nt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a> <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::nt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>template function giving the index of its template argument (index in GRAMMAR_TYPES). NOTE: The names here are decayed (meaning that references and base types are the same.</p>

</div>
</div>
<a id="a240019987945a694e26bebcebcf463fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240019987945a694e26bebcebcf463fc">&#9670;&nbsp;</a></span>rule_normalizer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::rule_normalizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normalizing constant (NOT log) for all rules of type nt </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aba4d092714b8420d8c0a1be63e8566b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4d092714b8420d8c0a1be63e8566b6">&#9670;&nbsp;</a></span>sample_rule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_rule.html">Rule</a>* <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::sample_rule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_nonterminal_8h.html#a1c5bfe9b903f69c83bbde5da7035fef3">nonterminal_t</a>&#160;</td>
          <td class="paramname"><em>nt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Randomly sample a rule of type nt. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a8d661258f08b7cc4d154d59bfbbc1f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d661258f08b7cc4d154d59bfbbc1f68">&#9670;&nbsp;</a></span>show()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::show </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;#&#160;&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given nt, returns the number of finite trees that nt can expand to if its finite; 0 if its infinite. * <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nt</td><td>- the type of this nonterminal </td></tr>
  </table>
  </dd>
</dl>
<p>Show the grammar by printing each rule</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4a0d1d38426ce7f1b68c001e9ddec064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0d1d38426ce7f1b68c001e9ddec064">&#9670;&nbsp;</a></span>GRAMMAR_MAX_DEPTH</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::GRAMMAR_MAX_DEPTH = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45877d4d7a5ee98bf6753af593d6ca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45877d4d7a5ee98bf6753af593d6ca08">&#9670;&nbsp;</a></span>N_NTs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::N_NTs = std::tuple_size&lt;std::tuple&lt;GRAMMAR_TYPES...&gt;&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a89ced0753d72f52ccf2b04c0ccc82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a89ced0753d72f52ccf2b04c0ccc82b">&#9670;&nbsp;</a></span>rules</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="class_rule.html">Rule</a>&gt; <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::rules[<a class="el" href="class_grammar.html#a45877d4d7a5ee98bf6753af593d6ca08">N_NTs</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63420ee4232c46523a46bd881cb3e2f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63420ee4232c46523a46bd881cb3e2f5">&#9670;&nbsp;</a></span>Z</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... GRAMMAR_TYPES&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="class_grammar.html">Grammar</a>&lt; GRAMMAR_TYPES &gt;::Z[<a class="el" href="class_grammar.html#a45877d4d7a5ee98bf6753af593d6ca08">N_NTs</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/Grammar/<a class="el" href="_grammar_8h_source.html">Grammar.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
