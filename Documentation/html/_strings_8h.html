<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Fleet: src/Strings.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_sm.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Fleet
   &#160;<span id="projectnumber">0.0.9</span>
   </div>
   <div id="projectbrief">Inference in the LOT</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Strings.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;queue&gt;</code><br />
<code>#include &lt;array&gt;</code><br />
<code>#include &lt;map&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;atomic&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &quot;<a class="el" href="_miscellaneous_8h_source.html">Miscellaneous.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_numerics_8h_source.html">Numerics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_random_8h_source.html">Random.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_vector3_d_8h_source.html">Vector3D.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Strings.h:</div>
<div class="dyncontent">
<div class="center"><img src="_strings_8h__incl.png" border="0" usemap="#src_2_strings_8h" alt=""/></div>
<map name="src_2_strings_8h" id="src_2_strings_8h">
<area shape="rect" title=" " alt="" coords="395,5,498,32"/>
<area shape="rect" title=" " alt="" coords="5,80,80,107"/>
<area shape="rect" title=" " alt="" coords="105,80,167,107"/>
<area shape="rect" title=" " alt="" coords="192,80,248,107"/>
<area shape="rect" title=" " alt="" coords="272,80,323,107"/>
<area shape="rect" title=" " alt="" coords="347,80,389,107"/>
<area shape="rect" title=" " alt="" coords="413,80,480,107"/>
<area shape="rect" title=" " alt="" coords="505,80,575,107"/>
<area shape="rect" href="_miscellaneous_8h.html" title=" " alt="" coords="599,80,726,107"/>
<area shape="rect" href="_numerics_8h.html" title=" " alt="" coords="635,155,731,181"/>
<area shape="rect" href="_random_8h.html" title="This is a thread_local rng whose first object is used to see others (in other threads)...." alt="" coords="825,80,913,107"/>
<area shape="rect" href="_vector3_d_8h.html" title=" " alt="" coords="1109,80,1203,107"/>
<area shape="rect" title=" " alt="" coords="533,155,611,181"/>
<area shape="rect" title=" " alt="" coords="443,155,509,181"/>
<area shape="rect" title=" " alt="" coords="647,229,719,256"/>
<area shape="rect" title=" " alt="" coords="543,229,623,256"/>
<area shape="rect" title=" " alt="" coords="351,229,425,256"/>
<area shape="rect" title=" " alt="" coords="450,229,518,256"/>
<area shape="rect" title=" " alt="" coords="923,155,997,181"/>
<area shape="rect" title=" " alt="" coords="1021,155,1107,181"/>
<area shape="rect" href="_errors_8h.html" title=" " alt="" coords="1177,155,1249,181"/>
<area shape="rect" href="_rng_8h.html" title=" " alt="" coords="840,155,899,181"/>
<area shape="rect" title=" " alt="" coords="1267,229,1354,256"/>
<area shape="rect" title=" " alt="" coords="1378,229,1465,256"/>
<area shape="rect" title=" " alt="" coords="1184,229,1243,256"/>
<area shape="rect" title=" " alt="" coords="1008,229,1072,256"/>
<area shape="rect" title=" " alt="" coords="1096,229,1160,256"/>
<area shape="rect" title=" " alt="" coords="743,229,849,256"/>
<area shape="rect" title=" " alt="" coords="873,229,983,256"/>
<area shape="rect" title=" " alt="" coords="1274,155,1337,181"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_strings_8h__dep__incl.png" border="0" usemap="#src_2_strings_8hdep" alt=""/></div>
<map name="src_2_strings_8hdep" id="src_2_strings_8hdep">
<area shape="rect" title=" " alt="" coords="2917,5,3019,32"/>
<area shape="rect" href="_i_o_8h.html" title=" " alt="" coords="2642,80,2713,107"/>
<area shape="rect" href="_discrete_distribution_8h.html" title="This stores a distribution from values of T to log probabilities. It is used as the return value from..." alt="" coords="2715,162,2976,189"/>
<area shape="rect" href="_shape_color_size_object_8h.html" title="This object is used in FOL and the set function experiments – just a handy function with a few conven..." alt="" coords="3167,162,3401,189"/>
<area shape="rect" href="_rule_8h.html" title="A Rule stores one possible expansion in the grammar, specifying a nonterminal type,..." alt="" coords="3425,162,3577,189"/>
<area shape="rect" href="_stack_8h.html" title="Many things in Fleet are stacks and this is designed to allow for rapid changse to the stack type in ..." alt="" coords="3531,80,3698,107"/>
<area shape="rect" href="_datum_8h.html" title="A datum is the default data point for likelihoods, consisting of an input and output type...." alt="" coords="2292,80,2428,107"/>
<area shape="rect" href="_base_node_8h.html" title="This is a general tree class, which we are adding because there are currently at least 3 different tr..." alt="" coords="2467,162,2589,189"/>
<area shape="rect" href="_grammar_8h.html" title="A grammar stores all of the rules associated with any kind of nonterminal and permits us to sample as..." alt="" coords="2982,341,3167,367"/>
<area shape="rect" href="_top_n_8h.html" title=" " alt="" coords="660,162,823,189"/>
<area shape="rect" href="_beam_search_8h.html" title="This is an implementation of beam search that maintains a priority queue of partial states and attemp..." alt="" coords="1837,430,2041,457"/>
<area shape="rect" href="_bayesable_8h.html" title="The Bayesable class provides an interface for hypotheses that support Bayesian inference (e...." alt="" coords="2518,244,2709,285"/>
<area shape="rect" href="_control_8h.html" title="This class has all the information for running MCMC or MCTS in a little package. It defaultly constru..." alt="" coords="1490,251,1659,278"/>
<area shape="rect" href="_builtins_8h.html" title="The Builtin type just stores a function pointer and an Op command. This makes it a bit handier to def..." alt="" coords="2999,155,3142,196"/>
<area shape="rect" href="_node_8h.html" title="A Node is the primary internal representation for a program – it recursively stores a rule and the ar..." alt="" coords="3176,251,3333,278"/>
<area shape="rect" href="_m_c_t_s_base_8h.html" title=" " alt="" coords="1472,512,1619,553"/>
<area shape="rect" href="_proposers_8h.html" title=" " alt="" coords="3192,341,3395,367"/>
<area shape="rect" href="_l_o_t_hypothesis_8h.html" title="A LOTHypothesis is the basic unit for doing LOT models. It store a Node as its value,..." alt="" coords="3314,430,3550,457"/>
<area shape="rect" href="_deterministic_l_o_t_hypothesis_8h.html" title=" " alt="" coords="3210,512,3425,553"/>
<area shape="rect" href="_stochastic_l_o_t_hypothesis_8h.html" title=" " alt="" coords="3449,512,3642,553"/>
<area shape="rect" href="_full_m_c_t_s_node_8h.html" title=" " alt="" coords="1293,601,1440,643"/>
<area shape="rect" href="_minimal_m_c_t_s_node_8h.html" title=" " alt="" coords="1464,601,1627,643"/>
<area shape="rect" href="_partial_m_c_t_s_node_8h.html" title=" " alt="" coords="1651,601,1802,643"/>
<area shape="rect" href="_base_grammar_hypothesis_8h.html" title="This class does grammar inference with some collection of HumanData and fixed set of hypotheses." alt="" coords="2118,512,2383,553"/>
<area shape="rect" href="_virtual_machine_pool_8h.html" title="A little class that any VirtualMachinePool AND VirtualMachines inherit to control their behavior...." alt="" coords="2937,244,3101,285"/>
<area shape="rect" href="_deterministic_grammar_hypothesis_8h.html" title="Here, the hypotheses are deterministic so we don&#39;t need Preidct_t to be a DiscreteDistribution,..." alt="" coords="1829,601,2094,643"/>
<area shape="rect" href="_full_grammar_hypothesis_8h.html" title="This class does grammar inference with some collection of HumanData and fixed set of hypotheses." alt="" coords="2118,601,2383,643"/>
<area shape="rect" href="_thunk_grammar_hypothesis_8h.html" title="A version of a BaseGrammarHypothesis where the hypotheses are thunks (functions of no arguments)...." alt="" coords="2407,601,2673,643"/>
<area shape="rect" href="_batch_8h.html" title=" " alt="" coords="1654,430,1813,457"/>
<area shape="rect" href="_hill_climbing_8h.html" title="This cute kind of inference keeps a body of N top hypotheses, and successively proposes to them using..." alt="" coords="412,341,615,367"/>
<area shape="rect" href="_reservoir_sample_8h.html" title="A simple resevoir sampling algorithm. One great disappointment is that this doesn&#39;t implement the ver..." alt="" coords="460,244,631,285"/>
<area shape="rect" href="_coroutines_8h.html" title=" " alt="" coords="805,251,987,278"/>
<area shape="rect" href="_testing_2_basics_2main_8cpp.html" title=" " alt="" coords="595,519,773,546"/>
<area shape="rect" href="_testing_2_detailed_balance_2main_8cpp.html" title=" " alt="" coords="53,423,232,464"/>
<area shape="rect" href="_testing_2_grammar_terminal_weights_2main_8cpp.html" title=" " alt="" coords="256,423,499,464"/>
<area shape="rect" href="_testing_2_insert_delete_probability_2main_8cpp.html" title=" " alt="" coords="573,423,795,464"/>
<area shape="rect" href="_threaded_inference_interface_8h.html" title="This manages multiple threads for running inference. This requires a subclass to define run_thread,..." alt="" coords="1231,333,1463,375"/>
<area shape="rect" href="_inference_2_enumeration_inference_8h.html" title="Enumeration inferences enumerates hypotheses using a counting algorithm from the grammar...." alt="" coords="1097,423,1290,464"/>
<area shape="rect" href="_m_c_m_c_chain_8h.html" title="This represents an MCMC hain on a hypothesis of type HYP. It uses HYP::propose and HYP::compute_poste..." alt="" coords="807,333,959,375"/>
<area shape="rect" href="_chain_pool_8h.html" title="A ChainPool stores a bunch of MCMCChains and allows you to run them serially or in parallel...." alt="" coords="920,423,1072,464"/>
<area shape="rect" href="_prior_inference_8h.html" title="Inference by sampling from the prior – doesn&#39;t tend to work well, but might be a useful baseline." alt="" coords="1365,430,1579,457"/>
<area shape="rect" href="_constant_container_8h.html" title=" " alt="" coords="3357,251,3616,278"/>
<area shape="rect" href="_m_c_m_cable_8h.html" title="A class is MCMCable if it is Bayesable and lets us propose, restart, and check equality (which MCMC d..." alt="" coords="2518,333,2709,375"/>
<area shape="rect" href="_lexicon_8h.html" title="A lexicon stores an association of numbers (in a vector) to some other kind of hypotheses (typically ..." alt="" coords="2218,430,2406,457"/>
<area shape="rect" href="_t_normal_variable_8h.html" title=" " alt="" coords="3030,423,3239,464"/>
<area shape="rect" href="_vector_half_normal_hypothesis_8h.html" title=" " alt="" coords="2430,423,2719,464"/>
<area shape="rect" href="_vector_normal_hypothesis_8h.html" title="A TNormalVariable encapsulates MCMC operations on a single real number with a standard normal prior...." alt="" coords="2743,423,3006,464"/>
<area shape="rect" href="_fleet_8h.html" title=" " alt="" coords="639,341,729,367"/>
<area shape="rect" href="_program_8h.html" title="A program here stores just a stack of instructions which can be executed by the VirtualMachineState_t..." alt="" coords="3652,155,3804,196"/>
<area shape="rect" href="_virtual_machine_state_8h.html" title="This represents the state of a partial evaluation of a program, corresponding to the value of all of ..." alt="" coords="3640,244,3811,285"/>
</map>
</div>
</div>
<p><a href="_strings_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4bc77a6f47e3046cc934b49f5e03a56f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4bc77a6f47e3046cc934b49f5e03a56f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a4bc77a6f47e3046cc934b49f5e03a56f">str</a> (T x)</td></tr>
<tr class="separator:a4bc77a6f47e3046cc934b49f5e03a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b313a5a03eda533ac68a4501c68c17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a21b313a5a03eda533ac68a4501c68c17">str</a> (const std::string &amp;x)</td></tr>
<tr class="separator:a21b313a5a03eda533ac68a4501c68c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab3d622399a5cd1e9fbaf8f38d8d394"><td class="memTemplParams" colspan="2">template&lt;typename... T, size_t... I&gt; </td></tr>
<tr class="memitem:a9ab3d622399a5cd1e9fbaf8f38d8d394"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a9ab3d622399a5cd1e9fbaf8f38d8d394">str</a> (const std::tuple&lt; T... &gt; &amp;x, std::index_sequence&lt; I... &gt; idx)</td></tr>
<tr class="separator:a9ab3d622399a5cd1e9fbaf8f38d8d394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fcc184e9e474c84204591dd7c95f1c"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:af4fcc184e9e474c84204591dd7c95f1c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#af4fcc184e9e474c84204591dd7c95f1c">str</a> (const std::tuple&lt; T... &gt; &amp;x)</td></tr>
<tr class="separator:af4fcc184e9e474c84204591dd7c95f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab510ae4356ff2e0f94525500dcdb9ada"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:ab510ae4356ff2e0f94525500dcdb9ada"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ab510ae4356ff2e0f94525500dcdb9ada">str</a> (const std::pair&lt; A, B &gt; x)</td></tr>
<tr class="separator:ab510ae4356ff2e0f94525500dcdb9ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc50785d7283d32f7f2e039e31b982"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a66fc50785d7283d32f7f2e039e31b982"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a66fc50785d7283d32f7f2e039e31b982">str</a> (const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a66fc50785d7283d32f7f2e039e31b982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1f39140cd40cc9f1868877e0e3d7c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec1f39140cd40cc9f1868877e0e3d7c2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#aec1f39140cd40cc9f1868877e0e3d7c2">str</a> (const std::vector&lt; T &gt; &amp;a, const std::string _sep=&quot;,&quot;)</td></tr>
<tr class="separator:aec1f39140cd40cc9f1868877e0e3d7c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff">str</a> (const std::map&lt; T, U &gt; &amp;a)</td></tr>
<tr class="separator:ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc7c2f6347e86df8696c3b14f4e0f58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:affc7c2f6347e86df8696c3b14f4e0f58"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#affc7c2f6347e86df8696c3b14f4e0f58">str</a> (const std::atomic&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:affc7c2f6347e86df8696c3b14f4e0f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a3109333f6ec7fc237e492a524da6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74a3109333f6ec7fc237e492a524da6a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a74a3109333f6ec7fc237e492a524da6a">to_string_with_precision</a> (const T a_value, const int n=14)</td></tr>
<tr class="separator:a74a3109333f6ec7fc237e492a524da6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63ed4e974b8dc3b49eae65049ad7804"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac63ed4e974b8dc3b49eae65049ad7804"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ac63ed4e974b8dc3b49eae65049ad7804">is_prefix</a> (const T &amp;prefix, const T &amp;x)</td></tr>
<tr class="memdesc:ac63ed4e974b8dc3b49eae65049ad7804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if prefix is a prefix of x &ndash; works with iterables, including strings and vectors.  <a href="_strings_8h.html#ac63ed4e974b8dc3b49eae65049ad7804">More...</a><br /></td></tr>
<tr class="separator:ac63ed4e974b8dc3b49eae65049ad7804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e236149ce0f5aa64d809fcca5cf1c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a9e236149ce0f5aa64d809fcca5cf1c27">contains</a> (const std::string &amp;s, const std::string &amp;x)</td></tr>
<tr class="separator:a9e236149ce0f5aa64d809fcca5cf1c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6424a030ce8c78fc72f206b0f92640e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a6424a030ce8c78fc72f206b0f92640e6">contains</a> (const std::string &amp;s, const char x)</td></tr>
<tr class="separator:a6424a030ce8c78fc72f206b0f92640e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f801c0b3a93e9baf742fc2ce79b1b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#aa9f801c0b3a93e9baf742fc2ce79b1b8">replace_all</a> (std::string &amp;s, const std::string &amp;x, const std::string &amp;y, int add=0)</td></tr>
<tr class="memdesc:aa9f801c0b3a93e9baf742fc2ce79b1b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurances of x with y in s.  <a href="_strings_8h.html#aa9f801c0b3a93e9baf742fc2ce79b1b8">More...</a><br /></td></tr>
<tr class="separator:aa9f801c0b3a93e9baf742fc2ce79b1b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006f42339c42d12497ad559987a8597c"><td class="memTemplParams" colspan="2">template&lt;const float &amp; add_p, const float &amp; del_p&gt; </td></tr>
<tr class="memitem:a006f42339c42d12497ad559987a8597c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a006f42339c42d12497ad559987a8597c">p_delete_append</a> (const std::string &amp;x, const std::string &amp;y, const float log_alphabet)</td></tr>
<tr class="memdesc:a006f42339c42d12497ad559987a8597c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability of converting x into y by deleting some number (each with del_p, then stopping with prob 1-del_p), adding with probability add_p, and then when we add selecting from an alphabet of size alpha_n.  <a href="_strings_8h.html#a006f42339c42d12497ad559987a8597c">More...</a><br /></td></tr>
<tr class="separator:a006f42339c42d12497ad559987a8597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d3a9b47a988443407a595730086318"><td class="memItemLeft" align="right" valign="top">std::deque&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a60d3a9b47a988443407a595730086318">split</a> (const std::string &amp;s, const char delimiter)</td></tr>
<tr class="memdesc:a60d3a9b47a988443407a595730086318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split is returns a deque of s split up at the character delimiter. It handles these special cases: split("a:", ':') -&gt; ["a", ""] split(":", ':') -&gt; [""] split(":a", ':') -&gt; ["", "a"].  <a href="_strings_8h.html#a60d3a9b47a988443407a595730086318">More...</a><br /></td></tr>
<tr class="separator:a60d3a9b47a988443407a595730086318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ae1cb99a3ece3691d6673b40b9d621"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#af8ae1cb99a3ece3691d6673b40b9d621">divide</a> (const std::string &amp;s, const char delimiter)</td></tr>
<tr class="separator:af8ae1cb99a3ece3691d6673b40b9d621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fc480ff96576142fbe0c1a5fc9114b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a51fc480ff96576142fbe0c1a5fc9114b">levenshtein_distance</a> (const std::string &amp;s1, const std::string &amp;s2)</td></tr>
<tr class="separator:a51fc480ff96576142fbe0c1a5fc9114b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6eafa3700b097b96c1601a141a45de4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ae6eafa3700b097b96c1601a141a45de4">count</a> (const std::string &amp;<a class="el" href="_strings_8h.html#affc7c2f6347e86df8696c3b14f4e0f58">str</a>, const std::string &amp;sub)</td></tr>
<tr class="separator:ae6eafa3700b097b96c1601a141a45de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95521755321516e684a5bf762eb001d7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a95521755321516e684a5bf762eb001d7">reverse</a> (std::string x)</td></tr>
<tr class="separator:a95521755321516e684a5bf762eb001d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7058817dff18bae565e0f06bb9492bc4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a7058817dff18bae565e0f06bb9492bc4">QQ</a> (std::string x)</td></tr>
<tr class="separator:a7058817dff18bae565e0f06bb9492bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb5ec0bee0c8456e3fcc87cc012d055"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a1bb5ec0bee0c8456e3fcc87cc012d055">Q</a> (std::string x)</td></tr>
<tr class="separator:a1bb5ec0bee0c8456e3fcc87cc012d055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dfce03cc4717ed6be9b64b04a695a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#adc4dfce03cc4717ed6be9b64b04a695a">check_alphabet</a> (const std::string &amp;s, const std::string &amp;a)</td></tr>
<tr class="memdesc:adc4dfce03cc4717ed6be9b64b04a695a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that s only uses characters from a. On failure, we print the string and assert false.  <a href="_strings_8h.html#adc4dfce03cc4717ed6be9b64b04a695a">More...</a><br /></td></tr>
<tr class="separator:adc4dfce03cc4717ed6be9b64b04a695a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e880c6337130fdcf52fec4edba062e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a8e880c6337130fdcf52fec4edba062e7">check_alphabet</a> (std::vector&lt; std::string &gt; t, const std::string &amp;a)</td></tr>
<tr class="separator:a8e880c6337130fdcf52fec4edba062e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b9409cdfb6a213710a66f0c02d5792"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ac4b9409cdfb6a213710a66f0c02d5792">p_KashyapOommen1984_edit</a> (const std::string x, const std::string y, const double perr, const size_t nalphabet)</td></tr>
<tr class="memdesc:ac4b9409cdfb6a213710a66f0c02d5792"><td class="mdescLeft">&#160;</td><td class="mdescRight">The string probability model from Kashyap &amp; Oommen, 1983, basically giving a string edit distance that is a probability model. This could really use some unit tests, but it is hard to find implementations.  <a href="_strings_8h.html#ac4b9409cdfb6a213710a66f0c02d5792">More...</a><br /></td></tr>
<tr class="separator:ac4b9409cdfb6a213710a66f0c02d5792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cda3705f8674293669932185337ebb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8cda3705f8674293669932185337ebb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#aa8cda3705f8674293669932185337ebb">string_to</a> (const std::string s)</td></tr>
<tr class="memdesc:aa8cda3705f8674293669932185337ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fleet includes this templated function to allow us to convert strings to a variety of formats. This is mostly used for reading data from text files. This recursively will unpack containers with some standard delimiters. Since it can handle Fleet types (e.g. defaultdata_t) it can be used to unpack data stored in strings (see e.g. Models/Sorting)  <a href="_strings_8h.html#aa8cda3705f8674293669932185337ebb">More...</a><br /></td></tr>
<tr class="separator:aa8cda3705f8674293669932185337ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6ea497303a7870c262ce682a282fb3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a9f6ea497303a7870c262ce682a282fb3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a9f6ea497303a7870c262ce682a282fb3">string_to</a> (const std::string s)</td></tr>
<tr class="separator:a9f6ea497303a7870c262ce682a282fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aefd49a74af3b4afc27512f639bcc336f"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#aefd49a74af3b4afc27512f639bcc336f">EMPTY_STRING</a> = &quot;&quot;</td></tr>
<tr class="separator:aefd49a74af3b4afc27512f639bcc336f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9e25e334b384128faea10ff26d9bc2"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#a9a9e25e334b384128faea10ff26d9bc2">LAMBDA_STRING</a> = &quot;\u03BB&quot;</td></tr>
<tr class="separator:a9a9e25e334b384128faea10ff26d9bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55885a972bc053c5f8ba3d4683f69b9"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_strings_8h.html#ac55885a972bc053c5f8ba3d4683f69b9">LAMBDAXDOT_STRING</a> = <a class="el" href="_strings_8h.html#a9a9e25e334b384128faea10ff26d9bc2">LAMBDA_STRING</a>+&quot;x.&quot;</td></tr>
<tr class="separator:ac55885a972bc053c5f8ba3d4683f69b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="adc4dfce03cc4717ed6be9b64b04a695a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4dfce03cc4717ed6be9b64b04a695a">&#9670;&nbsp;</a></span>check_alphabet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_alphabet </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that s only uses characters from a. On failure, we print the string and assert false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e880c6337130fdcf52fec4edba062e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e880c6337130fdcf52fec4edba062e7">&#9670;&nbsp;</a></span>check_alphabet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void check_alphabet </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6424a030ce8c78fc72f206b0f92640e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6424a030ce8c78fc72f206b0f92640e6">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e236149ce0f5aa64d809fcca5cf1c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e236149ce0f5aa64d809fcca5cf1c27">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6eafa3700b097b96c1601a141a45de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6eafa3700b097b96c1601a141a45de4">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t count </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many times does sub occur in str? Does not count overlapping substrings </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td></td></tr>
    <tr><td class="paramname">sub</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="af8ae1cb99a3ece3691d6673b40b9d621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ae1cb99a3ece3691d6673b40b9d621">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; divide </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac63ed4e974b8dc3b49eae65049ad7804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63ed4e974b8dc3b49eae65049ad7804">&#9670;&nbsp;</a></span>is_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool is_prefix </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if prefix is a prefix of x &ndash; works with iterables, including strings and vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>
<p>For any number of iterable types, is prefix a prefix of x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a51fc480ff96576142fbe0c1a5fc9114b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fc480ff96576142fbe0c1a5fc9114b">&#9670;&nbsp;</a></span>levenshtein_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int levenshtein_distance </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute levenshtein distiance between two strings (NOTE: Or O(N^2)) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s1</td><td></td></tr>
    <tr><td class="paramname">s2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a006f42339c42d12497ad559987a8597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006f42339c42d12497ad559987a8597c">&#9670;&nbsp;</a></span>p_delete_append()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const float &amp; add_p, const float &amp; del_p&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double p_delete_append </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>log_alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Probability of converting x into y by deleting some number (each with del_p, then stopping with prob 1-del_p), adding with probability add_p, and then when we add selecting from an alphabet of size alpha_n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">del_p</td><td>- probability of deleting the next character (geometric) </td></tr>
    <tr><td class="paramname">add_p</td><td>- probability of adding (geometric) </td></tr>
    <tr><td class="paramname">log_alphabet</td><td>- log of the size of alphabet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The probability of converting x to y by deleting characters with probability del_p and then adding with probability add_p </dd></dl>
<p>This function computes the probability that x would be converted into y, when we insert with probability add_p and delete with probabiltiy del_p and when we add we add from an alphabet of size log_alphabet. Note that this is a template function because otherwise we end up computing log(add_p) and log(del_p) a lot, and these are in fact constant. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">log_alphabet</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac4b9409cdfb6a213710a66f0c02d5792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b9409cdfb6a213710a66f0c02d5792">&#9670;&nbsp;</a></span>p_KashyapOommen1984_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double p_KashyapOommen1984_edit </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>perr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nalphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The string probability model from Kashyap &amp; Oommen, 1983, basically giving a string edit distance that is a probability model. This could really use some unit tests, but it is hard to find implementations. </p>
<p>This assumes that the deletions, insertions, and changes all happen with a constant, equal probability of perr, but note that swaps and insertions also have to choose the character out of nalphabet. This could probably be optimized to not have to compute these logs </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">perr</td><td></td></tr>
    <tr><td class="paramname">nalphabet</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a1bb5ec0bee0c8456e3fcc87cc012d055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb5ec0bee0c8456e3fcc87cc012d055">&#9670;&nbsp;</a></span>Q()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Q </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handy adding single quotes to a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7058817dff18bae565e0f06bb9492bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7058817dff18bae565e0f06bb9492bc4">&#9670;&nbsp;</a></span>QQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string QQ </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handy adding double quotes to a string </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>- input string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa9f801c0b3a93e9baf742fc2ce79b1b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f801c0b3a93e9baf742fc2ce79b1b8">&#9670;&nbsp;</a></span>replace_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>add</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurances of x with y in s. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">x</td><td></td></tr>
    <tr><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramname">add</td><td>&ndash; replace x plus this many characters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95521755321516e684a5bf762eb001d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95521755321516e684a5bf762eb001d7">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string reverse </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60d3a9b47a988443407a595730086318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d3a9b47a988443407a595730086318">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;std::string&gt; split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split is returns a deque of s split up at the character delimiter. It handles these special cases: split("a:", ':') -&gt; ["a", ""] split(":", ':') -&gt; [""] split(":a", ':') -&gt; ["", "a"]. </p>
<p>Split iwith a fixed return size, useful in parsing csv.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
    <tr><td class="paramname">delimiter</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a66fc50785d7283d32f7f2e039e31b982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66fc50785d7283d32f7f2e039e31b982">&#9670;&nbsp;</a></span>str() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="affc7c2f6347e86df8696c3b14f4e0f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc7c2f6347e86df8696c3b14f4e0f58">&#9670;&nbsp;</a></span>str() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::atomic&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fcb52c2f5a3b3dee61e4f5d3fdc1ff">&#9670;&nbsp;</a></span>str() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; T, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab510ae4356ff2e0f94525500dcdb9ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab510ae4356ff2e0f94525500dcdb9ada">&#9670;&nbsp;</a></span>str() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; A, B &gt;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a21b313a5a03eda533ac68a4501c68c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b313a5a03eda533ac68a4501c68c17">&#9670;&nbsp;</a></span>str() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af4fcc184e9e474c84204591dd7c95f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fcc184e9e474c84204591dd7c95f1c">&#9670;&nbsp;</a></span>str() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9ab3d622399a5cd1e9fbaf8f38d8d394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab3d622399a5cd1e9fbaf8f38d8d394">&#9670;&nbsp;</a></span>str() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T, size_t... I&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::tuple&lt; T... &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; I... &gt;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aec1f39140cd40cc9f1868877e0e3d7c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1f39140cd40cc9f1868877e0e3d7c2">&#9670;&nbsp;</a></span>str() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>_sep</em> = <code>&quot;,&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4bc77a6f47e3046cc934b49f5e03a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc77a6f47e3046cc934b49f5e03a56f">&#9670;&nbsp;</a></span>str() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string str </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>c A pythonesque string function </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa8cda3705f8674293669932185337ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cda3705f8674293669932185337ebb">&#9670;&nbsp;</a></span>string_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T string_to </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fleet includes this templated function to allow us to convert strings to a variety of formats. This is mostly used for reading data from text files. This recursively will unpack containers with some standard delimiters. Since it can handle Fleet types (e.g. defaultdata_t) it can be used to unpack data stored in strings (see e.g. Models/Sorting) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a9f6ea497303a7870c262ce682a282fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6ea497303a7870c262ce682a282fb3">&#9670;&nbsp;</a></span>string_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool string_to </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74a3109333f6ec7fc237e492a524da6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a3109333f6ec7fc237e492a524da6a">&#9670;&nbsp;</a></span>to_string_with_precision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string to_string_with_precision </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>a_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>n</em> = <code>14</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aefd49a74af3b4afc27512f639bcc336f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd49a74af3b4afc27512f639bcc336f">&#9670;&nbsp;</a></span>EMPTY_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string EMPTY_STRING = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a9e25e334b384128faea10ff26d9bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9e25e334b384128faea10ff26d9bc2">&#9670;&nbsp;</a></span>LAMBDA_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LAMBDA_STRING = &quot;\u03BB&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac55885a972bc053c5f8ba3d4683f69b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55885a972bc053c5f8ba3d4683f69b9">&#9670;&nbsp;</a></span>LAMBDAXDOT_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LAMBDAXDOT_STRING = <a class="el" href="_strings_8h.html#a9a9e25e334b384128faea10ff26d9bc2">LAMBDA_STRING</a>+&quot;x.&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
